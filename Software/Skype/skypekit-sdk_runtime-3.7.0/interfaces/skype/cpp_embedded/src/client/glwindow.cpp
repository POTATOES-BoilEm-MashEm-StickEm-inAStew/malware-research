#ifdef GL_WINDOW

#include "glwindow.h"
#include <stdio.h>

#ifdef __APPLE__
#include <OpenGL/CGLTypes.h>
#include <OpenGL/CGLContext.h>

#include <IOSurface/IOSurfaceAPI.h>
#include <OpenGL/CGLIOSurface.h>
#endif
#ifdef __linux__
#include <GL/freeglut.h>
#include <GL/freeglut_ext.h>
#endif

#ifdef _WIN32
#define usleep Sleep
//#include <gl/glext.h>
#else
#include <unistd.h>
#define USEGLUT	1
#endif


#ifdef VIDEO_TRANSPORT_IOSURFACE
static bool get_gl_format_for_fourcc(unsigned int fourcc,GLenum &int_format,GLenum &ext_format,GLenum &data_type)
{
	switch (fourcc)
	{
		case SFT_FOURCC_RGB32:
			int_format=GL_RGB8;
			ext_format=GL_BGRA;
			data_type=GL_UNSIGNED_INT_8_8_8_8_REV;
			return true;
#ifdef __APPLE__
		case SFT_FOURCC_UYVY:
			int_format=GL_RGB8;
			ext_format=GL_YCBCR_422_APPLE;
			data_type=GL_UNSIGNED_SHORT_8_8_APPLE;
			return true;
		case SFT_FOURCC_YUY2:
			int_format=GL_RGB8;
			ext_format=GL_YCBCR_422_APPLE;
			data_type=GL_UNSIGNED_SHORT_8_8_REV_APPLE;
			return true;
#endif
		default:
			return false;
	}
}
#endif

glWindow *glWindow::first = NULL;

#ifdef _WIN32
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_CREATE:
			return 0;
		case WM_CLOSE:
			PostQuitMessage( 0 );
			return 0; 
		case WM_DESTROY:
			return 0;
		case WM_KEYDOWN:
			switch ( wParam )
			{
				case VK_ESCAPE:
					PostQuitMessage(0);
					return 0;
			}
			return 0;
		default:
			return DefWindowProc( hWnd, message, wParam, lParam );
	}

}

void glWindow::WinCreateWindow()
{
	WNDCLASS wc;
	HWND hWnd;
	HGLRC hRC;
	MSG msg;
	
	// register window class
	wc.style = CS_OWNDC;
	wc.lpfnWndProc = WndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = NULL;
	wc.hIcon = LoadIcon( NULL, IDI_APPLICATION );
	wc.hCursor = LoadCursor( NULL, IDC_ARROW );
	wc.hbrBackground = (HBRUSH)GetStockObject( BLACK_BRUSH );
	wc.lpszMenuName = NULL;
	wc.lpszClassName = "GLSample";
	RegisterClass( &wc );

	// create main window
	hWnd = CreateWindow(
			"GLSample", "OpenGL Renderer",
			WS_CAPTION | WS_POPUPWINDOW | WS_VISIBLE,
			0, 0, 640, 480,
			NULL, NULL, NULL, NULL );

	PIXELFORMATDESCRIPTOR pfd;
	int format;

	hDC = GetDC( hWnd );

	ZeroMemory( &pfd, sizeof( pfd ) );
	pfd.nSize = sizeof( pfd );
	pfd.nVersion = 1;
	pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
	pfd.iPixelType = PFD_TYPE_RGBA;
	pfd.cColorBits = 24;
	pfd.cDepthBits = 16;
	pfd.iLayerType = PFD_MAIN_PLANE;
	format = ChoosePixelFormat( hDC, &pfd );
	SetPixelFormat( hDC, format, &pfd );

	hRC = wglCreateContext( hDC );
	wglMakeCurrent( hDC, hRC );
}
#endif

bool glWindow::glutinitialized = false;

glWindow::glWindow() :
	next( NULL ),
	textureWidth( 0 ),
	textureHeight( 0 )
{
#ifdef USEGLUT
	if ( !glutinitialized ) {
		int dummy = 1;
		const char *dargv[] = { "Test" };
		glutInit( &dummy, (char **)dargv );
		glutInitDisplayMode(GLUT_DOUBLE);
		glutinitialized = true;
	}

	glutInitWindowSize( 640, 480 );
	win_id = glutCreateWindow("video");
	glutDisplayFunc( displayFunc );
	glutIdleFunc(idleFunc);
#endif
#ifdef _WIN32
	WinCreateWindow();
#endif
	
	glGenTextures(1,&tex_id);

	glBindTexture(GL_TEXTURE_2D, tex_id );
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
		
	unsigned long rgb32 = 0x32334942;
	SetPreferences( &rgb32, 1 );
	//Start();
	
	next = first;
	first = this;
}

glWindow::~glWindow()
{
	if ( first == this )
		first = this->next;
	else {
		glWindow *w=first;
		while (w) {
			if ( w->next == this ) {
				w->next = this->next;
				break;
			}
		}
	}
}

#include <stdio.h>

void glWindow::idleFunc( void )
{
}

void glWindow::displayFunc( void )
{
}

#ifdef _WIN32
bool glWindow::Present( void *data, bufferstruct *b, long long ts )
{
	int w = b->width;
       int 	h = b->height;
	glBindTexture( GL_TEXTURE_2D, tex_id );
	if ( textureWidth != b->width || textureHeight != b->height ) {
		textureWidth = b->width;
		textureHeight = b->height;
		glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, w, h, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, data );
	}
								
	glTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, w, h, GL_BGRA_EXT, GL_UNSIGNED_BYTE, data );

	glClear( GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT );
	glEnable( GL_TEXTURE_2D );
	glBindTexture( GL_TEXTURE_2D, tex_id );
	glBegin(GL_QUADS);
	glTexCoord2f(0, 0);
	glVertex2f(-1, 1);
	glTexCoord2f(1, 0);
	glVertex2f(1, 1);
	glTexCoord2f(1, 1);
	glVertex2f(1, -1);
	glTexCoord2f(0, 1);
	glVertex2f(-1, -1);

	glEnd();
	glDisable(GL_TEXTURE_2D);
	
	SwapBuffers( hDC );

	return true;
}

#else
bool glWindow::Present( void *data, bufferstruct *b, long long ts )
{
	GLenum texturetarget;
	int owidth, oheight;
	if ( b->type == SkypekitVideoTransportBase::IOSurfaceBuffer ) {
#ifdef VIDEO_TRANSPORT_IOSURFACE
		owidth = b->width; oheight = b->height;
		texturetarget = GL_TEXTURE_RECTANGLE_ARB;
		glEnable(texturetarget);
		if ( !b->clientdata ) {
			IOSurfaceRef m_surface = IOSurfaceLookup(b->bufid);
			if ( !m_surface ) {
				printf( "Could not get surface\n" );
				return true; // We could not get surface, but we still wan't to releaes buffer.
			}
			GLuint tex_id;
			glGenTextures(1,&tex_id);
			b->clientdata = (void *)tex_id;
			glBindTexture(texturetarget, tex_id);
			GLenum int_format,ext_format,data_type;
			if ( !get_gl_format_for_fourcc((b->colorspace?b->colorspace:SFT_FOURCC_RGB32),int_format,ext_format,data_type) ) {
				printf( "Could not get formats based on fourcc: %lx\n", b->colorspace );
				return true;
			}
			CGLError err = CGLTexImageIOSurface2D(CGLGetCurrentContext(),GL_TEXTURE_RECTANGLE_ARB,int_format,b->width,b->height,ext_format,data_type,m_surface,0);
			if(err != kCGLNoError) {
				printf("Error creating IOSurface texture: %s & %x\n", CGLErrorString(err), glGetError());
			}
		} else {
			glBindTexture(texturetarget, (GLuint)b->clientdata);
		}
#endif
	} else {
		owidth = 1; oheight = 1;
		texturetarget = GL_TEXTURE_2D;
		glEnable(texturetarget);
		glBindTexture( texturetarget, tex_id );
		if ( textureWidth != b->width || textureHeight != b->height ) {
			textureWidth = b->width; textureHeight = b->height;
			glTexImage2D(texturetarget, 0, GL_RGB8, b->width, b->height, 0, GL_BGRA, GL_UNSIGNED_BYTE, data );
			glutReshapeWindow(textureWidth, textureHeight);
		} else {
			glTexSubImage2D(texturetarget, 0, 0, 0, b->width, b->height, GL_BGRA, GL_UNSIGNED_BYTE, data );
		}
	}


	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	glBegin(GL_QUADS);
	glTexCoord2f(0,0);
	glVertex2f(-1,1);
	glTexCoord2f(1,0);
	glVertex2f(1,1);
	glTexCoord2f(1,1);
	glVertex2f(1,-1);
	glTexCoord2f(0,1);
	glVertex2f(-1,-1);
	glEnd();
	glBindTexture(texturetarget,0);
	glDisable(texturetarget);
	glutSwapBuffers();
	return true;
}
#endif

void window_run_events()
{
#ifdef _WIN32
	MSG msg;
	if ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) ) {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	}
#endif
	glWindow *w;
	for( w = glWindow::first;w;w=w->next ) {
		w->ReceiveCommand( true );
	}
#ifdef USEGLUT
	if ( glWindow::first ) {
		glutCheckLoop();
		usleep(10000);
	}
#endif
}
#endif
