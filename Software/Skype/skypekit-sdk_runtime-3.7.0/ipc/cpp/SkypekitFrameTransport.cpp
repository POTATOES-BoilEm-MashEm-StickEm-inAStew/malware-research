/*
 * Copyright (C) 2010, Skype Limited
 *
 * All intellectual property rights, including but not limited to copyrights,
 * trademarks and patents, as well as know how and trade secrets contained
 * in, relating to, or arising from the internet telephony software of Skype
 * Limited (including its affiliates, "Skype"), including without limitation
 * this source code, Skype API and related material of such software
 * proprietary to Skype and/or its licensors ("IP Rights") are and shall
 * remain the exclusive property of Skype and/or its licensors. The recipient
 * hereby acknowledges and agrees that any unauthorized use of the IP Rights
 * is a violation of intellectual property laws.
 *
 * Skype reserves all rights and may take legal action against infringers of
 * IP Rights.
 *
 * The recipient agrees not to remove, obscure, make illegible or alter any
 * notices or indications of the IP Rights and/or Skype's rights and ownership
 * thereof.
 */

#ifdef SKYPEKIT_SURFACE_RENDERING


#ifdef __APPLE__
// If compiled for SL only then IOSurface, othewise SHM
#if (MAC_OS_X_VERSION_MIN_REQUIRED >= 1060)
#define TRANSPORT_USE_IOSURFACE 1
#else
#define TRANSPORT_USE_SHM 1
#endif
#else
// SHM for all
#define TRANSPORT_USE_SHM 1
#endif

#include "SkypekitFrameTransport.hpp"

#include <string.h>

#ifdef TRANSPORT_USE_IOSURFACE
#include <IOSurface/IOSurfaceAPI.h>
#include <CoreServices/Coreservices.h>
#include <CoreVideo/CVPixelBuffer.h>
#include <OpenGL/CGLIOSurface.h>
#endif

#ifdef TRANSPORT_USE_SHM
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <semaphore.h>
#endif

#define MY_PAGE_SIZE (65536)

// some helper functions

static unsigned int skype_fourcc_to_bpp(unsigned int fourcc)
{
	switch (fourcc)
	{
	case SFT_FOURCC_RGB32:
		return 4;

	case SFT_FOURCC_UYVY:
	case SFT_FOURCC_YUY2:
		return 2;

	default:
		return 0;
	}
}

static bool get_gl_format_for_fourcc(unsigned int fourcc,GLenum &int_format,GLenum &ext_format,GLenum &data_type)
{
	switch (fourcc)
	{
	case SFT_FOURCC_RGB32:
		int_format=GL_RGB8;
		ext_format=GL_BGRA;
		data_type=GL_UNSIGNED_INT_8_8_8_8_REV;
		return true;

#ifdef __APPLE__
	case SFT_FOURCC_UYVY:
		int_format=GL_RGB8;
		ext_format=GL_YCBCR_422_APPLE;
		data_type=GL_UNSIGNED_SHORT_8_8_APPLE;
		return true;

	case SFT_FOURCC_YUY2:
		int_format=GL_RGB8;
		ext_format=GL_YCBCR_422_APPLE;
		data_type=GL_UNSIGNED_SHORT_8_8_REV_APPLE;
		return true;
#else
// TODO:MESA YCbCr for linux?
#endif

	default:
		return false;
	}
}

static void copy_and_clip_bitmap(void *dest,void *src,unsigned int fourcc,
	unsigned int dest_width,unsigned int dest_pitch,unsigned int dest_height,
	unsigned int src_width,unsigned int src_pitch,unsigned int src_height)
{
	unsigned int copy_pixels=(src_width<dest_width)?src_width:dest_width;
	unsigned int copy_height=(src_height<dest_height)?src_height:dest_height;
	if (!copy_height || !copy_pixels) return;
	switch (fourcc)
	{
	case SFT_FOURCC_RGB32:
		 copy_pixels*=2;
	case SFT_FOURCC_UYVY:
	case SFT_FOURCC_YUY2:
		copy_pixels*=2;
		{
			char *d_arr=(char*)dest;
			char *s_arr=(char*)src;
			while (copy_height--)
			{
				memcpy(d_arr,s_arr,copy_pixels);
				d_arr+=dest_pitch;
				s_arr+=src_pitch;
			}
		}
		break;

	default:
		break;
	}
}

// Shm implementation

#ifdef TRANSPORT_USE_SHM


class ShmSkypekitFrameTransport : public SkypekitFrameTransport
{
public:
	// fourcc are fourcc values as defined in skype
	// pitch will be defined by the channel constraints.
	ShmSkypekitFrameTransport(unsigned int fourcc,unsigned int width,unsigned int height); // create new
	ShmSkypekitFrameTransport(unsigned int key); // open existing
	~ShmSkypekitFrameTransport();
	bool isInitialized();


	// Valid only if initialized
	unsigned int getKey();
	unsigned int getFourCC();
	unsigned int getWidth();
	unsigned int getHeight();
	unsigned int getBpp();
	unsigned int getPitch();
	void getSrcDimensions(unsigned int &width,unsigned int &height);
	
	// check if connection is still alive
	bool isClientConnected();

	// Check for a new frame
	bool hasNewFrame();
	void updateGLTexture(GLuint texture);
	// Called when UI needts to change/delete texture
	void resetGLTexture();

	void updateNewFrame(void *data,unsigned int width,unsigned int height,unsigned int pitch);
private:
	void lockSem();
	void unlockSem();

	bool m_server;
	bool m_initialized;
	bool m_texture_created;

	unsigned int m_seed;

	unsigned int m_fourcc;
	unsigned int m_width;
	unsigned int m_height;
	unsigned int m_bpp;
	// Posix SHM
	struct shmmem
	{
		uint32_t fourcc;
		uint32_t width;
		uint32_t height;
		uint32_t seed;
		// pitch is always bpp*width for shm (best performace for Svl)
		uint32_t src_width;
		uint32_t src_height;
		uint32_t client_connected;
		char data[];
	} __attribute__((packed));
	unsigned int m_key;
	int m_shm_fd;
	unsigned int m_bmap_size;
	shmmem *m_shm;
	sem_t *m_sem;
};


#define FILENAME_LENGTH (64)

static void print_shm_filename(char *name,unsigned int key)
{
	snprintf(name,FILENAME_LENGTH,"skypekit_shm_%08x",key);
}
static void print_sem_filename(char *name,unsigned int key)
{
	snprintf(name,FILENAME_LENGTH,"skypekit_sem_%08x",key);
}

ShmSkypekitFrameTransport::ShmSkypekitFrameTransport(unsigned int fourcc,unsigned int width,unsigned int height) :
	m_server(true),
	m_initialized(false),
	m_texture_created(false),
	m_seed(0),
	m_fourcc(fourcc),
	m_width(width),
	m_height(height),
	m_bpp(0),
	m_key(0),
	m_shm_fd(-1),
	m_bmap_size(0),
	m_shm(0),
	m_sem(0)
{
	m_bpp=skype_fourcc_to_bpp(fourcc);
	m_bmap_size=m_bpp*m_width*m_height;
	if (!m_bmap_size) return;
	m_bmap_size+=sizeof(shmmem);
	m_bmap_size=(m_bmap_size+MY_PAGE_SIZE-1)&~(MY_PAGE_SIZE-1);

	int tries=10;
	char shm_filename[FILENAME_LENGTH],sem_filename[FILENAME_LENGTH];
	srand(time(0));
	do
	{
		m_key=rand();
		if (!m_key) continue;
		print_shm_filename(shm_filename,m_key);
		m_shm_fd=shm_open(shm_filename,O_RDWR|O_CREAT|O_EXCL,0600);
	} while (m_shm_fd==-1 && tries--);

	if (m_shm_fd==-1) return;
		
	print_sem_filename(sem_filename,m_key);
	m_sem=sem_open(sem_filename,O_CREAT|O_EXCL,0600,0);
	if (m_sem==SEM_FAILED)
	{
		close(m_shm_fd);
		m_shm_fd=-1;
		shm_unlink(shm_filename);
		return;
	}
	sem_post(m_sem); // default is open

	if (!ftruncate(m_shm_fd,m_bmap_size))
	{
		m_shm=(shmmem*)mmap(0,m_bmap_size,PROT_READ|PROT_WRITE,MAP_SHARED,m_shm_fd,0);
		if (m_shm!=(void*)-1)
		{
			m_shm->fourcc=m_fourcc;
			m_shm->width=m_width;
			m_shm->height=m_height;
			m_shm->seed=0;
			m_shm->src_width=m_width;
			m_shm->src_height=m_height;
			m_shm->client_connected=0;
			m_initialized=1;
		}
	}
	if (!m_initialized)
	{
		sem_close(m_sem);
		close(m_shm_fd);
		m_shm_fd=-1;
		shm_unlink(shm_filename);
		sem_unlink(sem_filename);
	}
}

ShmSkypekitFrameTransport::ShmSkypekitFrameTransport(unsigned int key) :
	m_server(false),
	m_initialized(false),
	m_texture_created(false),
	m_seed(0),
	m_fourcc(0),
	m_width(0),
	m_height(0),
	m_bpp(0),
	m_key(key),
	m_shm_fd(-1),
	m_bmap_size(0),
	m_shm(0),
	m_sem(0)
{
	char shm_filename[FILENAME_LENGTH],sem_filename[FILENAME_LENGTH];
	print_sem_filename(sem_filename,m_key);
	m_sem=sem_open(sem_filename,0);
	if (m_sem==SEM_FAILED) return;

	print_shm_filename(shm_filename,m_key);
	m_shm_fd=shm_open(shm_filename,O_RDWR);
	if (m_shm_fd==-1)
	{
		sem_close(m_sem);
		return;
	}
	// first map one page to get the buffer dimensions
	m_shm=(shmmem*)mmap(0,MY_PAGE_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,m_shm_fd,0);
	if (m_shm==(void*)-1)
	{
		sem_close(m_sem);
		close(m_shm_fd);
		return;
	}
	m_fourcc=m_shm->fourcc;
	m_width=m_shm->width;
	m_height=m_shm->height;
	munmap(m_shm,MY_PAGE_SIZE);

	m_bpp=skype_fourcc_to_bpp(m_fourcc);
	m_bmap_size=m_bpp*m_width*m_height;
	if (!m_bmap_size)
	{
		sem_close(m_sem);
		close(m_shm_fd);
		return;
	}
	m_bmap_size+=sizeof(shmmem);
	m_bmap_size=(m_bmap_size+MY_PAGE_SIZE-1)&~(MY_PAGE_SIZE-1);
		
	// now the real mapping
	m_shm=(shmmem*)mmap(0,m_bmap_size,PROT_READ|PROT_WRITE,MAP_SHARED,m_shm_fd,0);
	if (m_shm==(void*)-1)
	{
		sem_close(m_sem);
		close(m_shm_fd);
		return;
	}
	m_shm->client_connected=1;
	m_initialized=1;
}

ShmSkypekitFrameTransport::~ShmSkypekitFrameTransport()
{
	if (!m_initialized) return;

	if (m_server) while (isClientConnected()) usleep(10000); // we are not dying before the other end is disconnected

	m_initialized=false;

	if (!m_server) m_shm->client_connected=0;
	munmap(m_shm,m_bmap_size);
	close(m_shm_fd);
	sem_close(m_sem);

	if (m_server)
	{
		char shm_filename[FILENAME_LENGTH],sem_filename[FILENAME_LENGTH];
		print_shm_filename(shm_filename,m_key);
		shm_unlink(shm_filename);
		print_sem_filename(sem_filename,m_key);
		sem_unlink(sem_filename);
	}
}

bool ShmSkypekitFrameTransport::isInitialized()
{
	return m_initialized;
}

unsigned int ShmSkypekitFrameTransport::getKey()
{
	if (!m_initialized) return 0;
	return m_key;
}

unsigned int ShmSkypekitFrameTransport::getFourCC()
{
	if (!m_initialized) return 0;
	return m_fourcc;
}

unsigned int ShmSkypekitFrameTransport::getWidth()
{
	if (!m_initialized) return 0;
	return m_width;
}

unsigned int ShmSkypekitFrameTransport::getHeight()
{
	if (!m_initialized) return 0;
	return m_height;
}

unsigned int ShmSkypekitFrameTransport::getPitch()
{
	if (!m_initialized) return 0;
	return m_width*m_bpp;
}

unsigned int ShmSkypekitFrameTransport::getBpp()
{
	if (!m_initialized) return 0;
	return m_bpp;
}

void ShmSkypekitFrameTransport::getSrcDimensions(unsigned int &width,unsigned int &height)
{
	if (!m_initialized) return;
	lockSem();
	width=m_shm->src_width;
	height=m_shm->src_height;
	unlockSem();
}

bool ShmSkypekitFrameTransport::isClientConnected()
{
	if (!m_initialized) return false;
	return m_shm->client_connected;
}

bool ShmSkypekitFrameTransport::hasNewFrame()
{
	if (!m_initialized) return false;
	return m_shm->seed!=m_seed;
}


void ShmSkypekitFrameTransport::updateGLTexture(GLuint texture)
{
	if (!m_initialized) return;

	if (!m_texture_created)
	{
		GLenum int_format,ext_format,data_type;
		if (!get_gl_format_for_fourcc(m_fourcc,int_format,ext_format,data_type)) return;
		glEnable(GL_TEXTURE_RECTANGLE_ARB);
		glBindTexture(GL_TEXTURE_RECTANGLE_ARB,texture);
#ifdef __APPLE_
		glTexParameteri(GL_TEXTURE_RECTANGLE_ARB,GL_TEXTURE_STORAGE_HINT_APPLE,GL_STORAGE_SHARED_APPLE);
		glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE,GL_TRUE);
#endif
		lockSem();
		glTexImage2D(GL_TEXTURE_RECTANGLE_ARB,0,int_format,m_width,m_height,0,ext_format,data_type,m_shm->data);
		m_seed=m_shm->seed;
		unlockSem();
		glBindTexture(GL_TEXTURE_RECTANGLE_ARB,0);
		glDisable(GL_TEXTURE_RECTANGLE_ARB);
		m_texture_created=true;
	} else if (m_shm->seed!=m_seed) {
		GLenum int_format,ext_format,data_type;
		if (!get_gl_format_for_fourcc(m_fourcc,int_format,ext_format,data_type)) return;
		glEnable(GL_TEXTURE_RECTANGLE_ARB);
		glBindTexture(GL_TEXTURE_RECTANGLE_ARB,texture);
		lockSem();
		glTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB,0,0,0,m_width,m_height,ext_format,data_type,m_shm->data);
		m_seed=m_shm->seed;
		unlockSem();
		glBindTexture(GL_TEXTURE_RECTANGLE_ARB,0);
		glDisable(GL_TEXTURE_RECTANGLE_ARB);
	}
}

void ShmSkypekitFrameTransport::resetGLTexture()
{
	m_texture_created=false;
}


void ShmSkypekitFrameTransport::updateNewFrame(void *data,unsigned int width,unsigned int height,unsigned int pitch)
{
	if (!m_initialized) return;

	lockSem();
	m_shm->seed++;
	m_shm->src_width=width;
	m_shm->src_height=height;
	if (m_width==width && m_bpp*m_width==pitch && m_height==height)
	{
		memcpy(m_shm->data,data,m_height*m_width*m_bpp);
	} else {
		copy_and_clip_bitmap(m_shm->data,data,m_fourcc,
			m_width,m_bpp*m_width,m_height,width,pitch,height);
	}
	unlockSem();
}

void ShmSkypekitFrameTransport::lockSem()
{
	sem_wait(m_sem);
}

void ShmSkypekitFrameTransport::unlockSem()
{
	sem_post(m_sem);
}

#endif



// IOSurface implementation

#ifdef TRANSPORT_USE_IOSURFACE

class IOSurfaceSkypekitFrameTransport : public SkypekitFrameTransport
{
public:
	// fourcc are fourcc values as defined in skype
	// pitch will be defined by the channel constraints.
	IOSurfaceSkypekitFrameTransport(unsigned int fourcc,unsigned int width,unsigned int height); // create new
	IOSurfaceSkypekitFrameTransport(unsigned int key); // open existing
	~IOSurfaceSkypekitFrameTransport();
	bool isInitialized();


	// Valid only if initialized
	unsigned int getKey();
	unsigned int getFourCC();
	unsigned int getWidth();
	unsigned int getHeight();
	unsigned int getBpp();
	unsigned int getPitch();
	void getSrcDimensions(unsigned int &width,unsigned int &height);
	
	// check if connection is still alive
	bool isClientConnected();

	// Check for a new frame
	bool hasNewFrame();
	void updateGLTexture(GLuint texture);
	// Called when UI needts to change/delete texture
	void resetGLTexture();

	void updateNewFrame(void *data,unsigned int width,unsigned int height,unsigned int pitch);
private:
	bool m_server;
	bool m_initialized;
	bool m_texture_created;

	unsigned int m_seed;

	unsigned int m_fourcc;
	unsigned int m_width;
	unsigned int m_height;
	unsigned int m_bpp;
	// IOSurface
	unsigned int m_src_width;
	unsigned int m_src_height;
	unsigned int m_dim_seed;
	unsigned int m_pitch;
	bool m_uses_iosurface;
	mach_port_t m_ioid;
	IOSurfaceRef m_surface;
};

static bool TestIOSurfaceAvail()
{
	SInt32 major,minor;
	if (Gestalt(gestaltSystemVersionMajor,&major)!=noErr) return false;
	if (Gestalt(gestaltSystemVersionMinor,&minor)!=noErr) return false;
	return (major>=10)&&(minor>=6);
}

static unsigned int skype_fourcc_to_pixelformat(unsigned int fourcc,unsigned int &bpp)
{
	bpp=skype_fourcc_to_bpp(fourcc);
	switch (fourcc)
	{
	case SFT_FOURCC_RGB32:
		return kCVPixelFormatType_32ABGR;

	case SFT_FOURCC_UYVY:
		return 'uyvy';

	case SFT_FOURCC_YUY2:
		return kCVPixelFormatType_422YpCbCr8;

	default:
		return 0;
	}
}

static unsigned int pixelformat_to_skype_fourcc(unsigned int pxlfmt)
{
	switch (pxlfmt)
	{
	case kCVPixelFormatType_32ABGR:
		return SFT_FOURCC_RGB32;

	case kCVPixelFormatType_422YpCbCr8:
		return SFT_FOURCC_YUY2;

	case 'uyvy':
		return SFT_FOURCC_UYVY;

	default:
		return 0;
	}
}

IOSurfaceSkypekitFrameTransport::IOSurfaceSkypekitFrameTransport(unsigned int fourcc,unsigned int width,unsigned int height) :
	m_server(true),
	m_initialized(false),
	m_texture_created(false),
	m_seed(0),
	m_fourcc(fourcc),
	m_width(width),
	m_height(height),
	m_bpp(0),
	m_src_width(0),
	m_src_height(0),
	m_dim_seed(0),
	m_pitch(0),
	m_uses_iosurface(TestIOSurfaceAvail()),
	m_ioid(0),
	m_surface(0)
{
	if (m_uses_iosurface)
	{
		unsigned int pxlfmt;
		pxlfmt=skype_fourcc_to_pixelformat(fourcc,m_bpp);
		if (pxlfmt)
		{
			m_pitch=IOSurfaceAlignProperty(kIOSurfaceBytesPerRow,m_bpp*m_width);

			CFNumberRef c_width,c_height,c_bpp,c_pitch,c_pxlfmt;
			SInt32 tmp_width=m_width;
			c_width=CFNumberCreate(0,kCFNumberSInt32Type,&tmp_width);
			SInt32 tmp_height=m_height;
			c_height=CFNumberCreate(0,kCFNumberSInt32Type,&tmp_height);
			SInt32 tmp_bpp=m_bpp;
			c_bpp=CFNumberCreate(0,kCFNumberSInt32Type,&tmp_bpp);
			SInt32 tmp_pitch=m_pitch;
			c_pitch=CFNumberCreate(0,kCFNumberSInt32Type,&tmp_pitch);
			OSType tmp_pxlfmt=pxlfmt;
			c_pxlfmt=CFNumberCreate(0,kCFNumberSInt32Type,&tmp_pxlfmt);	// TOOD: check OSType <> SInt32 mismatch
			CFDictionaryRef prop=CFDictionaryCreate(0,
				(const void*[]){kIOSurfaceWidth,kIOSurfaceHeight,kIOSurfaceBytesPerElement,kIOSurfaceBytesPerRow,kIOSurfacePixelFormat,kIOSurfaceIsGlobal},
				(const void*[]){c_width,c_height,c_bpp,c_pitch,c_pxlfmt,kCFBooleanTrue},
				6,&kCFTypeDictionaryKeyCallBacks,&kCFTypeDictionaryValueCallBacks);
			m_surface=IOSurfaceCreate(prop);
			CFRelease(c_width);
			CFRelease(c_height);
			CFRelease(c_bpp);
			CFRelease(c_pitch);
			CFRelease(c_pxlfmt);
			CFRelease(prop);
			if (m_surface)
			{
				//m_port=IOSurfaceCreateMachPort(m_surface);
				m_ioid=IOSurfaceGetID(m_surface);
				m_initialized=true;
			}
		}
	}
}

IOSurfaceSkypekitFrameTransport::IOSurfaceSkypekitFrameTransport(unsigned int key) :
	m_server(false),
	m_initialized(false),
	m_texture_created(false),
	m_seed(0),
	m_fourcc(0),
	m_width(0),
	m_height(0),
	m_bpp(0),
	m_src_width(0),
	m_src_height(0),
	m_dim_seed(0),
	m_pitch(0),
	m_uses_iosurface(TestIOSurfaceAvail()),
	m_ioid(key),
	m_surface(0)
{
	if (m_uses_iosurface)
	{
		//m_surface=IOSurfaceLookupFromMachPort(m_port);
		m_surface=IOSurfaceLookup(m_ioid);
		if (m_surface)
		{
			m_width=IOSurfaceGetWidth(m_surface);
			m_height=IOSurfaceGetHeight(m_surface);
			OSType pxlfmt=IOSurfaceGetPixelFormat(m_surface);
			m_pitch=IOSurfaceGetBytesPerRow(m_surface);
			m_fourcc=pixelformat_to_skype_fourcc(pxlfmt);
			m_bpp=skype_fourcc_to_bpp(m_fourcc);
			if (m_fourcc) m_initialized=true;
		}
	}
}

#define SRC_DIM_STRING "__skype_surface_src_dimensions"

IOSurfaceSkypekitFrameTransport::~IOSurfaceSkypekitFrameTransport()
{
	if (!m_initialized) return;

	if (m_server) while (isClientConnected()) usleep(10000); // we are not dying before the other end is disconnected

	m_initialized=false;
	if (m_uses_iosurface)
	{
		if (m_surface)
		{
			if (!m_server)
			{
				SInt32 tmp_dim=0;
				CFStringRef c_name=CFSTR(SRC_DIM_STRING);
				CFNumberRef c_dim=CFNumberCreate(0,kCFNumberSInt32Type,&tmp_dim);
				IOSurfaceSetValue(m_surface,c_name,c_dim);
				CFRelease(c_name);
				CFRelease(c_dim);
			}

			//if (m_server) mach_port_deallocate(mach_task_self(),m_port);
			//delete m_surface;
			m_surface=0;
		}
	}
}

bool IOSurfaceSkypekitFrameTransport::isInitialized()
{
	return m_initialized;
}

unsigned int IOSurfaceSkypekitFrameTransport::getKey()
{
	if (!m_initialized) return 0;

	if (m_uses_iosurface)
	{
		return m_ioid;
	} else return 0;
}

unsigned int IOSurfaceSkypekitFrameTransport::getFourCC()
{
	if (!m_initialized) return 0;
	return m_fourcc;
}

unsigned int IOSurfaceSkypekitFrameTransport::getWidth()
{
	if (!m_initialized) return 0;
	return m_width;
}

unsigned int IOSurfaceSkypekitFrameTransport::getHeight()
{
	if (!m_initialized) return 0;
	return m_height;
}

unsigned int IOSurfaceSkypekitFrameTransport::getPitch()
{
	if (!m_initialized) return 0;
	if (m_uses_iosurface)
	{
		return m_pitch;
	} else return 0;
}

unsigned int IOSurfaceSkypekitFrameTransport::getBpp()
{
	if (!m_initialized) return 0;
	return m_bpp;
}

void IOSurfaceSkypekitFrameTransport::getSrcDimensions(unsigned int &width,unsigned int &height)
{
	if (!m_initialized) return;

	if (m_uses_iosurface)
	{
		uint32_t seed=IOSurfaceGetSeed(m_surface);
		if (seed==m_dim_seed)
		{
			width=m_src_width;
			height=m_src_height;
			return;
		}
		m_dim_seed=seed;

		// Try to do this as atomically as possible
		SInt32 tmp_dim=m_width|(m_height<<16);
		CFStringRef c_name=CFSTR(SRC_DIM_STRING);
		CFNumberRef c_dim=(CFNumberRef)IOSurfaceCopyValue(m_surface,c_name);
		CFNumberGetValue(c_dim,kCFNumberSInt32Type,&tmp_dim);
		CFRelease(c_name);
		CFRelease(c_dim);
		m_src_width=tmp_dim&0xffff;
		m_src_height=tmp_dim>>16;

		width=m_src_width;
		height=m_src_height;
	}
}

bool IOSurfaceSkypekitFrameTransport::isClientConnected()
{
	if (!m_initialized) return false;

	if (m_uses_iosurface)
	{
		if (m_surface)
		{
			SInt32 tmp_dim=0;
			CFStringRef c_name=CFSTR(SRC_DIM_STRING);
			CFNumberRef c_dim=(CFNumberRef)IOSurfaceCopyValue(m_surface,c_name);
			CFNumberGetValue(c_dim,kCFNumberSInt32Type,&tmp_dim);
			CFRelease(c_name);
			CFRelease(c_dim);
			return !!tmp_dim;
		} else return false;
	} else return false;
}

bool IOSurfaceSkypekitFrameTransport::hasNewFrame()
{
	if (!m_initialized) return false;

	if (m_uses_iosurface)
	{
		return IOSurfaceGetSeed(m_surface)!=m_seed;
	} else return false;
}

void IOSurfaceSkypekitFrameTransport::updateGLTexture(GLuint texture)
{
	if (!m_initialized) return;

	if (m_uses_iosurface)
	{
		unsigned int seed=IOSurfaceGetSeed(m_surface);
		if (!seed) return; // dont create texture from random data from the buffer
		if (!m_texture_created)
		{
			GLenum int_format,ext_format,data_type;
			if (!get_gl_format_for_fourcc(m_fourcc,int_format,ext_format,data_type)) return;
			glEnable(GL_TEXTURE_RECTANGLE_ARB);
			glBindTexture(GL_TEXTURE_RECTANGLE_ARB,texture);
			CGLTexImageIOSurface2D(CGLGetCurrentContext(),GL_TEXTURE_RECTANGLE_ARB,int_format,m_width,m_height,ext_format,data_type,m_surface,0);
			glBindTexture(GL_TEXTURE_RECTANGLE_ARB,0);
			glDisable(GL_TEXTURE_RECTANGLE_ARB);
			m_texture_created=true;
		} else {
			// Nothing needed here for painting, lets just get a new seed
		}
		m_seed=seed;
	}
}

void IOSurfaceSkypekitFrameTransport::resetGLTexture()
{
	m_texture_created=false;
}

void IOSurfaceSkypekitFrameTransport::updateNewFrame(void *data,unsigned int width,unsigned int height,unsigned int pitch)
{
	if (!m_initialized) return;

	if (m_uses_iosurface)
	{
		IOSurfaceLock(m_surface,0,0);
		void *surface_data=IOSurfaceGetBaseAddress(m_surface);
		// since we cant really change the properties of the surface we
		// notify with properties if we would like to have different sized buffer
		// so the responsible party can recreate the buffer
		// currently we copy the data fully into IOSurface if it fits, or not at all
		// but we will notify the other end about the size
		//
		// Due to the fact that IOSurface texture updates automatically, we have to preserve
		// the geometry of the buffer
		//
		// It is assumed that data is in the right pitch advertised

		if (m_src_width!=width || m_src_height!=height)
		{
			// Try to do this as atomically as possible
			SInt32 tmp_dim=width|(height<<16);
			CFStringRef c_name=CFSTR(SRC_DIM_STRING);
			CFNumberRef c_dim=CFNumberCreate(0,kCFNumberSInt32Type,&tmp_dim);
			IOSurfaceSetValue(m_surface,c_name,c_dim);
			CFRelease(c_name);
			CFRelease(c_dim);
			m_src_width=width;
			m_src_height=height;
		}

		if (m_width==width && m_pitch==pitch && m_pitch==m_bpp*m_width && m_height==height)
		{
			memcpy(surface_data,data,m_height*m_pitch);
		} else {
			copy_and_clip_bitmap(surface_data,data,m_fourcc,
				m_width,m_pitch,m_height,width,pitch,height);
		}
		IOSurfaceUnlock(m_surface,0,0);
	}
}

#endif

// Factory

SkypekitFrameTransport *SkypekitFrameTransport::CreateTransport(unsigned int fourcc,unsigned int width,unsigned int height)
{
#ifdef TRANSPORT_USE_IOSURFACE
	return new IOSurfaceSkypekitFrameTransport(fourcc,width,height);
#endif
#ifdef TRANSPORT_USE_SHM
	return new ShmSkypekitFrameTransport(fourcc,width,height);
#endif
}

SkypekitFrameTransport *SkypekitFrameTransport::OpenTransport(unsigned int key)
{
#ifdef TRANSPORT_USE_IOSURFACE
	return new IOSurfaceSkypekitFrameTransport(key);
#endif
#ifdef TRANSPORT_USE_SHM
	return new ShmSkypekitFrameTransport(key);
#endif
}

SkypekitFrameTransport::~SkypekitFrameTransport() {}

#endif
