/*
 * Copyright (C) 2007-2009 Skype Technologies S.A. Confidential and proprietary
 *
 * All intellectual property rights, including but not limited to copyrights,
 * trademarks and patents, as well as know how and trade secrets contained
 * in, relating to, or arising from the internet telephony software of Skype
 * Limited (including its affiliates, "Skype"), including without limitation
 * this source code, Skype API and related material of such software
 * proprietary to Skype and/or its licensors ("IP Rights") are and shall
 * remain the exclusive property of Skype and/or its licensors. The recipient
 * hereby acknowledges and agrees that any unauthorized use of the IP Rights
 * is a violation of intellectual property laws.
 *
 * Skype reserves all rights and may take legal action against infringers of
 * IP Rights.
 *
 * The recipient agrees not to remove, obscure, make illegible or alter any
 * notices or indications of the IP Rights and/or Skype's rights and ownership
 * thereof.
 */

#include "ShmTransport.hpp"

//#define SID_LOG_MASK 0x1f
//#define SID_DBG_TIMESTAMPS 1
#include "SidDebugging.hpp"

#include <string.h>
#include <stdio.h>
#include <assert.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>


#define SID_READ_BARRIER {}
#define SID_WRITE_BARRIER {}

#define SHM_CBUF_SIZE (65536)

#define SID_CBDBG(fmt, args...) _SID_LOG(SID_DBG_TIMESTAMPS, 0x20, fmt, ##args)

namespace Sid {

void ShmCircBuffer::Init(void *shm,unsigned int size) {
	m_Map=(ShmCbufMapping*)shm;
	m_Map->wr_addr=0;
	m_Map->rd_addr=0;
	m_Bufsize=size-sizeof(ShmCbufMapping);
}

unsigned int ShmCircBuffer::CopyTo(const char *src,unsigned int maxlen,bool &was_empty,bool &is_full)
{
	SID_READ_BARRIER
	unsigned int tmp_rd_addr=m_Map->rd_addr;
	unsigned int blk_size=m_Map->wr_addr-tmp_rd_addr+((tmp_rd_addr>m_Map->wr_addr)?m_Bufsize:0);
	// full?
	// do not use the last 4 bytes of the buffer in order to distinguish between full & empty.
	// why 4 and not 1 byte? In case sender is wise and sends data sized align 4, we dont
	// have to use unaligned memcpys on embedded.
	if (blk_size+4==m_Bufsize)
	{
		was_empty=false;
		is_full=true;
		return 0;
	}
	was_empty=(tmp_rd_addr==m_Map->wr_addr);
	// now calculate the size of the data needed
	blk_size=m_Bufsize-4-blk_size;
	if (maxlen<blk_size)
	{
		blk_size=maxlen;
		is_full=false;
	} else is_full=true;

	unsigned int tmp_addr=m_Map->wr_addr;

	if (tmp_addr+blk_size>m_Bufsize)
	{
		unsigned int buf_left=m_Bufsize-tmp_addr;
		memcpy(m_Map->data+tmp_addr,src,buf_left);
		memcpy(m_Map->data,src+buf_left,blk_size-buf_left);
		tmp_addr=blk_size-buf_left;
	} else {
		memcpy(m_Map->data+tmp_addr,src,blk_size);
		tmp_addr+=blk_size;
	}

	SID_WRITE_BARRIER
	m_Map->wr_addr=tmp_addr;
	if (is_full)
	{
		// make sure the last write is synchronized if buffer is full
		SID_WRITE_BARRIER
	}

	return blk_size;
}

unsigned int ShmCircBuffer::CopyFrom(char *dst,unsigned int maxlen,bool &was_full,bool &is_empty)
{
	SID_READ_BARRIER
	unsigned int tmp_wr_addr=m_Map->wr_addr;
	unsigned int blk_size=tmp_wr_addr-m_Map->rd_addr+((m_Map->rd_addr>tmp_wr_addr)?m_Bufsize:0);
	was_full=(blk_size+4==m_Bufsize);
	if (maxlen<blk_size)
	{
		blk_size=maxlen;
		is_empty=false;
	} is_empty=true;

	unsigned int tmp_addr=m_Map->rd_addr;
	if (tmp_addr+blk_size>m_Bufsize)
	{
		unsigned int buf_left=m_Bufsize-tmp_addr;
		memcpy(dst,m_Map->data+tmp_addr,buf_left);
		memcpy(dst+buf_left,m_Map->data,blk_size-buf_left);
		tmp_addr=blk_size-buf_left;
	} else {
		memcpy(dst,m_Map->data+tmp_addr,blk_size);
		tmp_addr+=blk_size;
	}

	SID_WRITE_BARRIER
	m_Map->rd_addr=tmp_addr;
	if (is_empty)
	{
		// make sure the last write is synchronized if buffer is empty
		SID_WRITE_BARRIER
	}

	return blk_size;
}


AVTransport * GetAVTransport() {
	return new ShmTransport();
}


class FileLock {
public:
	FileLock() :
		m_Fd(-1),
		m_Locked(false)
		{}
	~FileLock() {
		Unlock();
	}
	bool Lock(const char * fname) {
		m_Fname = fname;
		SID_DBG("Lock: %s", m_Fname);

		m_Fd = open(fname, O_WRONLY | O_CREAT, 0600);
		if (m_Fd < 0) {
			SID_ERROR("Failed to open file: %d (%s)", errno, strerror(errno));
			return false;
		}

		struct flock flck;
		memset(&flck,0,sizeof(struct flock));
		flck.l_type=F_WRLCK;
		if (fcntl(m_Fd,F_SETLK,&flck) < 0) {
			SID_ERROR("Failed to lock file: %d (%s)", errno, strerror(errno));
			Unlock();
			return false;
		}
		m_Locked = true;
		return true;
	}
	void Unlock() {
		SID_DBG("Unlock: %s", m_Fname);
		if (m_Fd != -1) {
			if (m_Locked) {
				struct flock flck;
				memset(&flck,0,sizeof(struct flock));
				flck.l_type=F_UNLCK;
				fcntl(m_Fd,F_SETLK,&flck);
				m_Locked = false;
			}
			close(m_Fd);
			m_Fd = -1;
		}
	}
	static bool TestLocked(const char * fname, bool &locked) {
		SID_DBG("TestLocked: %s", fname);

		int fd = open(fname, O_WRONLY, 0600);
		if (fd < 0) {
			SID_ERROR("Failed to open file:  %s %d (%s)", fname, errno, strerror(errno));
			return false;
		}
		struct flock flck;
		memset(&flck,0,sizeof(struct flock));
		flck.l_type=F_WRLCK;
		fcntl(fd,F_GETLK,&flck);
		locked = (flck.l_type & F_UNLCK? false: true);
		close(fd);
		SID_DBG("TestLocked: %s ret: %d %d", fname, flck.l_type, locked);
		return true;
	}
	int m_Fd;
	bool m_Locked;
	const char * m_Fname;
};

ShmTransport::ShmTransport() :
	m_ServerMode(false) {
	m_Shm = GetShm();
	m_WrEmptySem = GetSem();
	m_RdEmptySem = GetSem();
	m_WrFullSem = GetSem();
	m_RdFullSem = GetSem();
	m_ConnSem = GetSem();
	m_ServerFlock = new FileLock();
}

ShmTransport::~ShmTransport(void) {
	Disconnect();
	delete m_Shm;
	delete m_WrEmptySem;
	delete m_RdEmptySem;
	delete m_WrFullSem;
	delete m_RdFullSem;
	delete m_ConnSem;
	delete m_ServerFlock;
}

bool ShmTransport::ServerConnect(int timeout_ms) {
	bool ret = m_Shm->Init(m_Key, SHM_CBUF_SIZE * 2, m_ServerMode);
	if (!ret)
		goto serv_conn_error;

	m_WrCbuf.Init(m_Shm->GetMemPtr(),SHM_CBUF_SIZE);
	m_RdCbuf.Init(m_Shm->GetMemPtr()+SHM_CBUF_SIZE,SHM_CBUF_SIZE);

	if (!m_WrEmptySem->Init(m_Key, "wresem", true, 0))
		goto serv_conn_error;
	if (!m_RdEmptySem->Init(m_Key, "rdesem", true, 0))
		goto serv_conn_error;
	if (!m_WrFullSem->Init(m_Key, "wrfsem", true, 0))
		goto serv_conn_error;
	if (!m_RdFullSem->Init(m_Key, "rdfsem", true, 0))
		goto serv_conn_error;
	if (!m_ConnSem->Init(m_Key, "connsem", true, 0))
		goto serv_conn_error;

	// lock the file when everything is initialized - this tells client that it may connect
	if (!m_ServerFlock->Lock(m_Key))
		goto serv_conn_error;

	SID_DBG( "ShmComm::Connect(server) %s - waiting client...", m_Key);
	if (!m_ConnSem->Wait(timeout_ms))
		goto serv_conn_error;
	SID_DBG( "ShmComm::Connect(server) %s - client connected", m_Key);

	m_Connected = true;
	return true;

serv_conn_error:
	SID_ERROR("ShmComm::ServerConnect %s failed", m_Key);
	Disconnect();
	return false;
}

bool ShmTransport::ClientConnect() {
	bool ret;
	bool server_connected;

	// test if server has locked the key file. If not, can't connect yet
	ret = FileLock::TestLocked(m_Key, server_connected);
	if (!ret)
		goto client_conn_error;

	if (!server_connected) {
		SID_ERROR("Server not connected yet!");
		goto client_conn_error;
	}

	ret = m_Shm->Init(m_Key, SHM_CBUF_SIZE * 2, m_ServerMode);
	if (!ret)
		goto client_conn_error;

	m_RdCbuf.Init(m_Shm->GetMemPtr(),SHM_CBUF_SIZE);
	m_WrCbuf.Init(m_Shm->GetMemPtr()+SHM_CBUF_SIZE,SHM_CBUF_SIZE);

	if (!m_RdEmptySem->Init(m_Key, "wresem", false, 0))
		goto client_conn_error;
	if (!m_WrEmptySem->Init(m_Key, "rdesem", false, 0))
		goto client_conn_error;
	if (!m_RdFullSem->Init(m_Key, "wrfsem", false, 0))
		goto client_conn_error;
	if (!m_WrFullSem->Init(m_Key, "rdfsem", false, 0))
		goto client_conn_error;
	if (!m_ConnSem->Init(m_Key, "connsem", false, 0))
		goto client_conn_error;

	SID_DBG( "ShmComm::Connect(client) %s - notify server", m_Key);
	if (!m_ConnSem->Signal())
		goto client_conn_error;

	m_Connected = true;
	return true;

client_conn_error:
	SID_ERROR("ShmComm::_Connect %s failed", m_Key);
	Disconnect();
	return false;
}

bool ShmTransport::Connect(const char *key, bool serverMode, int timeout_ms) {
	m_ServerMode = serverMode;
	strncpy(m_Key, key, sizeof(m_Key));
	if (serverMode) {
		return ServerConnect(timeout_ms);
	} else {
		bool ret;
		int elapsed_ms = 0;
		do {
			ret = ClientConnect();
			if (!ret) {
				usleep(100000);
				elapsed_ms += 100;
			}
		} while (!ret && (timeout_ms < 0 || elapsed_ms < timeout_ms));
		return ret;
	}
}

void ShmTransport::Disconnect() {
	m_Shm->Uninit();
	m_WrEmptySem->Uninit();
	m_RdEmptySem->Uninit();
	m_WrFullSem->Uninit();
	m_RdFullSem->Uninit();
	m_ConnSem->Uninit();
	if (m_ServerMode)
		m_ServerFlock->Unlock();
	m_Connected = false;
}

bool ShmTransport::WriteStart() {
	return true;
}

bool ShmTransport::Write(const char *buf, int count) {
	unsigned int pos=0;
	while (pos!=count)
	{
		bool was_empty;
		bool is_full;
		pos+=m_WrCbuf.CopyTo(buf+pos,count-pos,was_empty,is_full);
		if (pos!=count && is_full)
		{
			m_WrEmptySem->Signal(); // deadlock if we dont
			m_WrFullSem->Wait();
		} else if (was_empty) m_WrEmptySem->Signal();
	}
	return true;
}

bool ShmTransport::WriteComplete() {
	return true;
}

bool ShmTransport::ReadStart() {
	return true;
}

bool ShmTransport::Read(char *buf, int count) {
	unsigned int pos=0;
	while (pos!=count)
	{
		bool was_full;
		bool is_empty;
		pos+=m_RdCbuf.CopyFrom(buf+pos,count-pos,was_full,is_empty);
		if (pos!=count && is_empty)
		{
			m_RdFullSem->Signal(); // deadlock if we dont
			m_RdEmptySem->Wait();
		} else if (was_full) m_RdFullSem->Signal();
	}
	return true;
}

bool ShmTransport::ReadComplete() {
	return true;
}

}
