/*
 * Copyright (C) 2007-2009 Skype Technologies S.A. Confidential and proprietary
 *
 * All intellectual property rights, including but not limited to copyrights,
 * trademarks and patents, as well as know how and trade secrets contained
 * in, relating to, or arising from the internet telephony software of Skype
 * Limited (including its affiliates, "Skype"), including without limitation
 * this source code, Skype API and related material of such software
 * proprietary to Skype and/or its licensors ("IP Rights") are and shall
 * remain the exclusive property of Skype and/or its licensors. The recipient
 * hereby acknowledges and agrees that any unauthorized use of the IP Rights
 * is a violation of intellectual property laws.
 *
 * Skype reserves all rights and may take legal action against infringers of
 * IP Rights.
 *
 * The recipient agrees not to remove, obscure, make illegible or alter any
 * notices or indications of the IP Rights and/or Skype's rights and ownership
 * thereof.
 */

#include "SocketTransport.hpp"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <errno.h>

//#define SID_LOG_MASK 0xFF
#include "SidDebugging.hpp"

namespace Sid {

AVTransport * GetAVTransport() {
	return new SocketTransport();
}

SocketTransport::SocketTransport() :
	m_WrBufCnt(0),
	m_RdBufCnt(0),
	m_RdBufRdAddr(0) {

	m_Socket = GetSocket();
	assert(m_Socket);
}

SocketTransport::~SocketTransport() {
	delete m_Socket;
}

bool SocketTransport::Connect(const char *key, bool serverMode, int timeout_ms) {
	strncpy(m_Key, key, sizeof(m_Key));
	return m_Socket->Connect(m_Key, serverMode, timeout_ms);
}

void SocketTransport::Disconnect() {
	m_Socket->Disconnect();
}

/* Implements the logic needed to write the whole buffer. If socket is full then
 * polls until can write more*/
bool SocketTransport::WriteBuffer(const char *buf, int count) {
	SID_VDBG("WriteBuffer: %d", count);
	int rv;
	do {
		rv = m_Socket->Write(buf, count);
		if (rv > 0) {
			SID_VDBG("Wrote successfully %d", rv);
			count -= rv;
			buf += rv;
		// if write failed because socket internal buffers are full then poll until
		// we can write more
		} else if (errno == EAGAIN) {
			SID_VDBG("Write errno == EAGAIN, polling");
			rv = m_Socket->PollWrite();
			SID_VDBG("write poll ret: %d", rv);
			if (rv < 0) {
				SID_ERROR("write poll failed ret error: %d", errno);
				return false;
			}
		} else {
			SID_ERROR("write failed errno: %d", errno);
			return false;
		}
	} while (count > 0);

	return true;
}

bool SocketTransport::WriteComplete() {
	SID_VDBG("FlushWrite, wr_buf_count: %d", m_WrBufCnt);
	if (!m_WrBufCnt)
		return true;
	bool ret = WriteBuffer(m_WrBuf, m_WrBufCnt);
	m_WrBufCnt = 0;
	return ret;
}

bool SocketTransport::Write(const char *buf, int count) {
	SID_DBG("SocketTransport::Write %d", count);
	bool rv = true;

	do {
		if (count > IPCCOMM_WR_BUF_LEN) {
			rv = WriteComplete();
			if (!rv)
				break;
			rv = WriteBuffer(buf, count);
		} else {
			if (m_WrBufCnt + count > IPCCOMM_WR_BUF_LEN) {
				rv = WriteComplete();
				if (!rv)
					break;
			}

			if (count < 4) {
				for (int i = 0; i < count; i++) {
					m_WrBuf[m_WrBufCnt++] = ((char*) buf)[i];
				}
			} else {
				memcpy(m_WrBuf + m_WrBufCnt, (char*) buf, count);
				m_WrBufCnt += count;
			}
		}
	} while (0);

	return rv;
}

inline int SocketTransport::ReadToBuf(char * buf, int count, int max_count) {
	SID_VDBG("ReadToBuf %d %d", count, max_count);
	int rv;
	int read_count = 0;
	while(read_count < count) {
		rv = m_Socket->Read(&buf[read_count], max_count - read_count);
		if (rv > 0) {
			SID_VDBG("Read successfully: %d", rv);
			read_count += rv;
		} else if (errno == EAGAIN && read_count < count) {
			SID_VDBG("Read errno == EAGAIN, polling");
			bool poll_ret = m_Socket->PollRead();
			SID_VDBG("Read poll ret: %d", poll_ret);
			if (!poll_ret) {
				SID_ERROR("Poll error: %d", errno);
				return -1;
			}
		} else {
			SID_ERROR("Read error: %d", errno);
			return -1;
		}
	}
	return read_count;
}

/* Reads at least count bytes to read buf, but may read up to IPCCOMM_RD_BUF_LEN if more is available */
inline bool SocketTransport::ReadToReadBuf(int count) {
	int ret;
	SID_VDBG("ReadToReadBuf %d", count);
	assert(m_RdBufCnt == 0);
	ret = ReadToBuf(m_RdBuf, count, IPCCOMM_RD_BUF_LEN);
	if (ret >= count) {
		m_RdBufCnt += ret;
		return true;
	} else {
		return false;
	}
}

/* read number of bytes from read buf */
inline int SocketTransport::ReadFromRdBuf(char * buf, int count) {
	int ret;
	SID_VDBG("ReadFromRdBuf: count %d, rd_buf_rd_addr: %d, rd_buf_count: %d", count, m_RdBufRdAddr, m_RdBufCnt);
	if (count < m_RdBufCnt) {
		memcpy(buf, &m_RdBuf[m_RdBufRdAddr], count);
		m_RdBufRdAddr += count;
		m_RdBufCnt -= count;
		ret = count;
	} else {
		memcpy(buf, &m_RdBuf[m_RdBufRdAddr], m_RdBufCnt);
		ret = m_RdBufCnt;
		m_RdBufRdAddr = 0;
		m_RdBufCnt = 0;
	}
	return ret;
}

/* read count bytes to user buffer */
inline bool SocketTransport::ReadToUserBuf(char * buf, int count) {
	SID_VDBG("ReadToUserBuf %d", count);
	int ret = ReadToBuf(buf, count, count);
	if (ret == count) {
		return true;
	} else {
		return false;
	}
}

bool SocketTransport::Read(char * buf, int count) {
	bool rv = true;

	SID_DBG("SocketTransport::Read: %d", count);
	if (count == 0)
		return true;

	do {
		int remaining_count = count;
		int read_count = 0;
		// check if we have data in read buffer
		if (m_RdBufCnt) {
			read_count = ReadFromRdBuf(buf, count);
			remaining_count-= read_count;
			if (!remaining_count)
				break;
		}

		/* read to read buffer at least remaining_count and up to IPCCOMM_RD_BUF_LEN bytes*/
		if (remaining_count <= IPCCOMM_RD_BUF_LEN) {
			rv = ReadToReadBuf(remaining_count);
			if (!rv)
				break;
			ReadFromRdBuf(&buf[read_count], remaining_count);
		/* For larger reads we read directly to user buffer to avoid memcpy */
		} else {
			rv = ReadToUserBuf(&buf[read_count], remaining_count);
			if (!rv)
				break;
		}
	} while (0);

	return rv;
}

}

