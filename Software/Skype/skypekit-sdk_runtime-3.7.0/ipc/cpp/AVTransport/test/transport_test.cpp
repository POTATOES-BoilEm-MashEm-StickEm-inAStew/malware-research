/*
 * asd.cpp
 *
 *  Created on: May 3, 2010
 *      Author: lauri
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "AVTransport.hpp"
#include <stdlib.h>
#include <unistd.h>

//#define SID_LOG_MASK 0x3f
#define SID_DBG_TIMESTAMPS 1

#include "SidDebugging.hpp"
#define MAX_BUFLEN 1996
char buf[MAX_BUFLEN + 4];


struct OptionsParser {
	OptionsParser() :
		m_IpcPrefix("/tmp/"),
		m_Help(false),
		m_TestNr(-1),
		m_ServerMode(-1),
		m_TestCnt(-1),
		m_CheckData(false) {
	}
	void Usage(const char *executable) {
		SID_INFO("usage:");
		SID_INFO("	%s [options]", executable);
		SID_INFO("	options:");
		SID_INFO("		-h - print help");
		SID_INFO("		-t test_nr - test number: 1 = random read/write, 2 = last message test, 3 - perfo test");
		SID_INFO("			1 - random read/write");
		SID_INFO("			2 - last message test");
		SID_INFO("			3 - perfo test");
		SID_INFO("		-s server_mode - 1 - act as server, 0 - act as client");
		SID_INFO("		-c test_count - number of tests");
		SID_INFO("		-k ipc key prefix - key prefix for ipc");
		SID_INFO("		-C - check data");
	}
	int ParseOptions(int argc, const char **argv) {
		for (int i = 1; i < argc; i++) {
			const char c = argv[i][0];
			if (c == '-' || c == '/') {
				switch (argv[i][1]) {
				case 'h': {
					m_Help = true;
					break;
				}
				case 't': {
					if (i + 1 >= argc)
						return -1;
					m_TestNr = atoi(argv[++i]);
					break;
				}
				case 's': {
					if (i + 1 >= argc)
						return -1;
					m_ServerMode = atoi(argv[++i]);
					break;
				}
				case 'c': {
					if (i + 1 >= argc)
						return -1;
					m_TestCnt = atoi(argv[++i]);
					break;
				}
				case 'C': {
					m_CheckData = true;
					break;
				}
				case 'k': {
					if (i + 1 >= argc)
						return -1;
					m_IpcPrefix = argv[++i];
					break;
				}
				default: {
					return -1;
					break;
				}
				}
			} else {
				return -1;
			}
		}

		if (m_TestNr < 0 || m_ServerMode < 0 || m_TestCnt < 0) {
			return -1;
		}

		return 0;
	}
	const char *m_IpcPrefix;
	bool m_Help;
	int m_TestNr;
	bool m_ServerMode;
	int m_TestCnt;
	bool m_CheckData;
};

int RandomSendRecv(OptionsParser &options) {

	printf("server_mode: %d, testcnt: %d\n", options.m_ServerMode, options.m_TestCnt);

	if(options.m_ServerMode) {
		Sid::AVTransport* test = Sid::GetAVTransport();

		if (!test->Connect(options.m_IpcPrefix, true, -1)) {
			SID_ERROR("test->Connect(server) failed");
			return -1;
		}

		for (int i = 0; i < options.m_TestCnt; i++) {
			int buflen = MAX_BUFLEN * (rand() / (float)RAND_MAX);
			*((int *)buf) = buflen;
			for (int j = 0; j < buflen; j++) {
				buf[4 + j] = (char)j;
			}
			SID_VDBG("write buffer: %d\n", buflen);
			int towrite = 4 + buflen;
			int written = 0;
			test->WriteStart();
			do {
				int wrlen;
				if (towrite > 3) {
					wrlen = towrite * (rand() / (float)RAND_MAX);
				} else {
					wrlen = towrite;
				}
				SID_VDBG("write: %d, %d\n", wrlen, towrite);
				test->Write(&buf[written], wrlen);
				towrite -= wrlen;
				written += wrlen;
			} while(towrite);
			test->WriteComplete();
		}
		printf("press enter\n");
		char asd[100];
		gets(asd);
	} else {
		Sid::AVTransport* test = Sid::GetAVTransport();

		if (!test->Connect(options.m_IpcPrefix, false, 1000)) {
			SID_ERROR("test->Connect(client) failed");
			return -1;
		}


		for (int i = 0; i < options.m_TestCnt; i++) {
			test->ReadStart();
			char lenbuf[4];
			test->Read(lenbuf, 4);
			int len = *((int*)lenbuf);
			SID_VDBG("read buffer: %d\n", len);

			int toread = len;
			int read = 0;
			do {
				int rdlen;
				if (toread > 3) {
					rdlen = toread * (rand() / (float)RAND_MAX);
				} else {
					rdlen = toread;
				}
				SID_VDBG("read: %d, %d\n", rdlen, toread);
				test->Read(&buf[read], rdlen);
				toread -= rdlen;
				read += rdlen;
			} while(toread);
			test->ReadComplete();

			for (int j = 0; j < len; j++) {
				if (buf[j] != (char)j) {
					SID_ERROR("error: buf: %d, len: %d, j: %d, char: %d, instead of %d\n", i, len, j, buf[j], (char)j);
				}
			}
		}
		printf("press enter\n");
		char asd[100];
		gets(asd);
	}
	return 0;
}

int LastMsgTest(OptionsParser &options) {

	if(options.m_ServerMode) {
		Sid::AVTransport* test = Sid::GetAVTransport();

		if (!test->Connect(options.m_IpcPrefix, true, -1)) {
			SID_ERROR("test->Connect(server) failed");
			return -1;
		}

		for (int i = 0; i < options.m_TestCnt; i++) {
			int bufcnt = 10 * (rand() / (float)RAND_MAX);
			SID_VDBG("write & read %d buffers\n", bufcnt);
			for (int j = 0; j < bufcnt; j++) {
				int buflen = MAX_BUFLEN * (rand() / (float)RAND_MAX);
				*((int *)buf) = buflen;/*
				for (int j = 0; j < buflen; j++) {
					buf[4 + j] = (char)j;
				}*/
				SID_VDBG("write buffer: %d\n", buflen);
				int towrite = 4 + buflen;
				test->WriteStart();
				test->Write(buf, towrite);
				test->WriteComplete();
			}
			for (int j = 0; j < bufcnt; j++) {
				test->ReadStart();
				test->Read(buf, 4);
				int len = *((int*)buf);
				SID_VDBG("read buffer: %d\n", len);

				test->Read(&buf[4], len);
				test->ReadComplete();
/*
				for (int j = 0; j < len; j++) {
					if (buf[4 + j] != (char)j) {
						SID_ERROR("error: buf: %d, len: %d, j: %d, char: %d, instead of %d\n", i, len, j, buf[j], (char)j);
					}
				}*/
			}
		}
		printf("press enter\n");
		char asd[100];
		gets(asd);
	} else {
		Sid::AVTransport* test = Sid::GetAVTransport();

		if (!test->Connect(options.m_IpcPrefix, false, 1000)) {
			SID_ERROR("test->Connect(client) failed");
			return -1;
		}

		while (1) {
			test->ReadStart();
			test->Read(buf, 4);
			int len = *((int*)buf);
			SID_VDBG("read buffer: %d\n", len);

			test->Read(&buf[4], len);
			test->ReadComplete();

/*
			for (int j = 0; j < len; j++) {
				if (buf[4 + j] != (char)j) {
					SID_ERROR("error: buf: %d, len: %d, j: %d, char: %d, instead of %d\n", i, len, j, buf[j], (char)j);
				}
			}*/

			SID_VDBG("write buffer: %d\n", len);
			test->WriteStart();
			test->Write(buf, len + 4);
			test->WriteComplete();
		}
		printf("press enter\n");
		char asd[100];
		gets(asd);
	}
	return 0;
}

int PerfoTest(OptionsParser &options) {

	printf("server_mode: %d, bufcnt: %d\n", options.m_ServerMode,  options.m_TestCnt);

	if(options.m_ServerMode) {
		Sid::AVTransport* test = Sid::GetAVTransport();

		if (!test->Connect(options.m_IpcPrefix, true, -1)) {
			SID_ERROR("test->Connect(server) failed");
			return -1;
		}

		for (int i = 0; i < options.m_TestCnt; i++) {
			int buflen = 1400;
			*((int *)buf) = buflen;
			if (options.m_CheckData) {
				for (int j = 0; j < buflen; j++) {
					buf[4 + j] = (char)j;
				}
			}
			SID_VDBG("write buffer: %d\n", buflen);
			int towrite = 4 + buflen;
			test->WriteStart();
			test->Write(buf, towrite);
			test->WriteComplete();
		}
//		printf("press enter\n");
//		char asd[100];
//		gets(asd);
	} else {
		Sid::AVTransport* test = Sid::GetAVTransport();

		if (!test->Connect(options.m_IpcPrefix, false, 1000)) {
			SID_ERROR("test->Connect(client) failed");
			return -1;
		}

		for (int i = 0; i < options.m_TestCnt; i++) {
			test->ReadStart();
			test->Read(buf, 4);
			int len = *((int*)buf);
			SID_VDBG("read buffer: %d\n", len);

			test->Read(&buf[4], len);
			test->ReadComplete();

			if (options.m_CheckData) {
				for (int j = 0; j < len; j++) {
					if (buf[4 + j] != (char)j) {
						SID_ERROR("error: buf: %d, len: %d, j: %d, char: %d, instead of %d\n", i, len, j, buf[j], (char)j);
					}
				}
			}
		}
//		printf("press enter\n");
//		char asd[100];
//		gets(asd);
	}
	return 0;
}


int main(int argc, const char **argv) {
	OptionsParser parser;
	if (parser.ParseOptions(argc, argv) < 0 || parser.m_Help) {
		parser.Usage(argv[0]);
		return -1;
	}

	if (parser.m_TestNr == 1) {
		return RandomSendRecv(parser);
	} else if (parser.m_TestNr == 2) {
		return LastMsgTest(parser);
	} else {
		return PerfoTest(parser);
	}
}
