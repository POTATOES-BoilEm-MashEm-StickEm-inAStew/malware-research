
#ifdef SKYPEKIT_SURFACE_RENDERING

#include "SkypekitVideoTransportClient.hpp"

#ifndef _WIN32
#include <sys/shm.h>
#include <sys/sem.h>
#endif

#include <string.h>
#include <stdio.h>
#include <errno.h>

#if _SEM_SEMUN_UNDEFINED == 1
union semun {
	int              val;    /* Value for SETVAL */
	struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
	unsigned short  *array;  /* Array for GETALL, SETALL */
	struct seminfo  *__buf;  /* Buffer for IPC_INFO
				    (Linux specific) */
};
#endif

SkypekitVideoTransportClient::SkypekitVideoTransportClient() :
	latest_data(NULL)
{
	ssize = sizeof(commandstruct)+sizeof(bufferstruct)*VID_BUFFERS+
		sizeof(int)*2+sizeof(unsigned long)*20;
#ifdef _WIN32
	hMapFile = CreateNewMapping( ssize, &comm_id );
	if ( !AttachSharedMemory( hMapFile ) ) {
		CloseHandle( hMapFile );
		hMapFile = NULL;
		return;
	}
	CreateNewSemaphoreSet( sem_id );
#else
	comm_id = shmget( IPC_PRIVATE, ssize, IPC_CREAT|0777);
	if ( !AttachSharedMemory( comm_id ) )
		return;
	*sem_id = semget( IPC_PRIVATE, 4, IPC_CREAT|0600 );
	union semun s;
	s.val = 0;
	for( int i=0;i<4;i++ )
		semctl( *sem_id, i, SETVAL, s );
	s.val = 1;
	semctl( *sem_id, SemSendCommand, SETVAL, s );
	for( int i=0;i<4;i++ ) {
		semctl( *sem_id, i, GETVAL, 0 );
	}
#endif
	for( int i=0;i<VID_BUFFERS;i++ ) {
		buffer_data[i].bufid = -1;
		buffer_data[i].available = false;
		buffer_data[i].usagecount = 0;
		buffer_data[i].clientdata = 0;
	}
};

SkypekitVideoTransportClient::~SkypekitVideoTransportClient()
{
	DetachSharedMemory();
#ifndef _WIN32
	shmctl( comm_id, IPC_RMID, 0 );
#endif
}

bool SkypekitVideoTransportClient::SetPreferences(unsigned long *colorspaces, int count )
{
	if ( count > 20 )
		return false;
	int *cshm = (int *)(pref_data);
	*cshm = count;
	if ( !count )
		return true;
	uint64 cbuf[20];
	for( int i=0;i<count;i++ )
		cbuf[i] = colorspaces[i];
	memcpy( (pref_data+sizeof(int)), cbuf, count*sizeof(uint64) );
#if 0
	int c = 0;
	for( int i=0;i<20;i++ ) {
		printf( "%2i: ", i+1 );
		for( int j=0;j<16;j++ ) {
			if ( ssize < ++c )
				break;
			printf( "%02X ", shm_data[i*20+j] );
		}
		if ( ssize < c )
			break;
		printf( "\n" );
	}
#endif
	return true;
}


void SkypekitVideoTransportClient::Run( void )
{
	while( 1 ) {
		ReceiveCommand( false );
	}
}

bool SkypekitVideoTransportClient::ReceiveCommand( bool nowait )
{
#ifdef _WIN32
	DWORD sret = WaitForSingleObject( semaphores[SemReceivedCommand], (nowait? 0 : INFINITE ) );
	if ( sret == WAIT_TIMEOUT )
		return true;
	if ( sret != WAIT_OBJECT_0 ) {
		printf( "Semaphore error\n" );
		return false;
	}
	commandstruct ccommand = *command_data;
	ReleaseSemaphore( semaphores[SemSendCommand], 1, NULL );
#else
	struct sembuf sop;
	sop.sem_num = SemReceivedCommand;
	sop.sem_op = -1;
	sop.sem_flg = (short)(nowait? IPC_NOWAIT:0);
	int err = semop( *sem_id, &sop, 1 );
	if ( err == -1 ) {
		if ( errno == EAGAIN )
			return true;
		return false;
	}
	commandstruct ccommand = *command_data;
	sop.sem_num = SemSendCommand;
	sop.sem_op = 1;
	sop.sem_flg = 0;
	semop( *sem_id, &sop, 1 );
#endif
	if( ccommand.command == 'A' ) {
		bufferstruct *b = &buffer_data[ccommand.idata];
		if ( Allocate( b ) ) {
			b->usagecount=1;
			AddFreeBuffer( b );
		}
	} else if( ccommand.command == 'P' ) {
		bufferstruct *b = &buffer_data[ccommand.idata];
		bufferstruct *tmp = latest_data;
		latest_data = b;
		latest_data->usagecount++;
		if ( tmp )
			AddFreeBuffer( tmp );
		b->usagecount++;
		if ( Present( b, ccommand.lldata ) )
			AddFreeBuffer( b );
	} else if( ccommand.command == 'R' ) {
		bufferstruct *b = &buffer_data[ccommand.idata];
		FreeBuffer( b );
		if ( Allocate( b ) ) {
			b->usagecount=1;
			AddFreeBuffer( b );
		}
	}
	return true;
}


SkypekitVideoTransportBase::bufferstruct * SkypekitVideoTransportClient::LatestBuffer()
{
	// TODO usagecount might need locking
	bufferstruct *tmp = latest_data;
	if ( !tmp )
		return NULL;
	tmp->usagecount++;
	return tmp;
}

void SkypekitVideoTransportClient::AddFreeBuffer( bufferstruct *b )
{
	if( --b->usagecount > 0 )
		return;
	b->available = true;
#ifdef _WIN32
	ReleaseSemaphore( semaphores[SemAvailableBuffers], 1, NULL );
#else
	struct sembuf sop;
	sop.sem_num = SemAvailableBuffers;
	sop.sem_op = 1;
	sop.sem_flg = 0;
	semop( *sem_id, &sop, 1 );
#endif
}

int SkypekitVideoTransportClient::pitchfor( unsigned long colorspace, int bitsPerPixel, int width, int /*height*/ )
{
	return bitsPerPixel/8*width;
}
#endif
