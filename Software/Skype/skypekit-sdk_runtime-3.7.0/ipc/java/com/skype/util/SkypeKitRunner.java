/**
 * Copyright (C) 2010, Skype Limited
 *
 * All intellectual property rights, including but not limited to copyrights,
 * trademarks and patents, as well as know how and trade secrets contained in,
 * relating to, or arising from the internet telephony software of
 * Skype Limited (including its affiliates, "Skype"), including without
 * limitation this source code, Skype API and related material of such
 * software proprietary to Skype and/or its licensors ("IP Rights") are and
 * shall remain the exclusive property of Skype and/or its licensors.
 * The recipient hereby acknowledges and agrees that any unauthorized use of
 * the IP Rights is a violation of intellectual property laws.
 *
 * Skype reserves all rights and may take legal action against infringers of
 * IP Rights.
 *
 * The recipient agrees not to remove, obscure, make illegible or alter any
 * notices or indications of the IP Rights and/or Skype's rights and
 * ownership thereof.
 */

package com.skype.util;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;


import android.content.Context;
import android.content.res.Resources;
import android.util.Log;

public class SkypeKitRunner implements Runnable {
	private static final String TAG = "SkypeKitRunner";

//	public static final String SKYPEKIT_PARAMETERS = " -p 663 -d log.log -f /data/data/com.skype.Skype4Android/files/";
	public static final String SKYPEKIT_PARAMETERS_PREFIX_TCPSOCKET = " -P ";
	public static final String SKYPEKIT_PARAMETERS_PREFIX_LOCALSOCKET = " -l SkypeKit";
	public static final String SKYPEKIT_PARAMETERS_NETLOGGING_DISABLED = " -x";
	public static final String SKYPEKIT_PARAMETERS_NO_TLS = " -n";
	public static final String SKYPEKIT_PARAMETERS_NETLOGGING_ENABLED = "";
	public static final String SKYPEKIT_PARAMETERS_POSTFIX_LOGGING = " -d log.log -f ";
	public static final String SKYPEKIT_PARAMETERS_POSTFIX_NOT_LOGGING = " -f ";
	public static final String SKYPEKIT_PARAMETERS_AUDIO_IPC_KEY = " -sa ";
	public static final String SKYPEKIT_PARAMETERS_VIDEO_IPC_KEY = " -sv ";
	public static final String SKYPEKIT_PARAMETERS_INCREASE_IPC_THREADS = " -T 3 -t 3 ";
	public static final int SKYPEKIT_DEFAULT_PORT = 1663;
	
	// "ANDROID_PROPERTY_WORKSPACE"
	// simple string obfuscation
	private static final char[] ENVNAMECOMPONENTS={
		0x73,0x28,0xf4,
		0x5b,0x59,0xf6,		
		(char) ('A'^0x05^0xe2),0x05,0xe2,
		(char) ('N'^0x55^0x33),0x55,0x33,
		(char) ('D'^0x2f^0x11),0x2f,0x11,
		(char) ('R'^0xf6^0x81),0xf6,0x81,
		(char) ('O'^0x68^0x72),0x68,0x72,
		(char) ('I'^0x89^0xf6),0x89,0xf6,
		(char) ('D'^0xd2^0xf5),0xd2,0xf5,
		(char) ('_'^0xbb^0x12),0xbb,0x12,
		(char) ('P'^0xb9^0x67),0xb9,0x67,
		(char) ('R'^0x52^0xb2),0x52,0xb2,
		(char) ('O'^0x33^0xb3),0x33,0xb3,
		(char) ('P'^0x13^0x31),0x13,0x31,
		(char) ('E'^0x24^0x95),0x24,0x95,
		(char) ('R'^0x48^0xa3),0x48,0xa3,
		(char) ('T'^0x7f^0xff),0x7f,0xff,
		(char) ('Y'^0x77^0xe9),0x77,0xe9,
		(char) ('_'^0x11^0x15),0x11,0x15,
		(char) ('W'^0x02^0x36),0x02,0x36,
		(char) ('O'^0x08^0x01),0x08,0x01,
		(char) ('R'^0xa4^0x89),0xa4,0x89,
		(char) ('K'^0xa3^0x13),0xa3,0x13,
		(char) ('S'^0xca^0x74),0xca,0x74,
		(char) ('P'^0xbc^0x19),0xbc,0x19,
		(char) ('A'^0x98^0x20),0x98,0x20,
		(char) ('C'^0x54^0x03),0x54,0x03,
		(char) ('E'^0x98^0x04),0x98,0x04,
		0x99,0x1e,0x88,		
		0x33,0xe9,0xee,		
		0xc2,0x10,0x29,		
		0xb5,0x59,0xa6		
	};
	// spice for md5 calculation of csf file contents.
	private static final byte[] MAITSEAINE={
		(byte)0x99,0x62,0x48,(byte)0xda,(byte)0xa9,(byte)0xf4,0x06,(byte)0xc2
	};

	private Context mContext;
	private Listener mListener;
	private String mSkypeKitOptions = null;

	private static boolean mIsAppRunning;
	private Process mAppProcess = null;
	private boolean mStopNotify = false;

	/**
	 * Interface to be implemented by listener.
	 * 
	 * @author Skype
	 * 
	 */
	public interface Listener {
		/**
		 * The SkypeKit process was stopped normally.
		 */
		public void skypekitStopped();
	}

	protected void finalize()
	{
		stopApp();
	}
	
	/**
	 * Constructor setting the required environment to do the handling. Create
	 * an instance or this class and use {@link #startApp()} to have the
	 * application launched in a separate thread.
	 * 
	 * @param context
	 *            Main application context to load the resource with
	 * @param resid
	 *            Main application resource to load as application
	 * @param listener
	 *            Listener implementation to notify
	 * @see #startApp()
	 */
	public SkypeKitRunner(Context context) {
	    mContext = context;
		mListener = null;
	}

	/**
	 * Try to start the application. This function will block the caller thread
	 * until the application process is started in a new thread. Use
	 * {@link #isAppRunning()} to check if the application is actually started
	 * and running when this function returns. Default options are used.
	 * 
	 * @see #isAppRunning()
	 */
	public void startApp()
	{
		startApp(false,SKYPEKIT_DEFAULT_PORT,false, "/tmp/", "/tmp/", false, false);
	}
	
	public void startApp(boolean logging)
	{
		startApp(logging,SKYPEKIT_DEFAULT_PORT,false, "/tmp/", "/tmp/", false, false);
	}
	
	public void startApp(boolean logging, int port)
	{
		startApp(logging,port,false, "/tmp/", "/tmp/", false, false);
	}

	public void startApp(boolean logging, int port, boolean netlogging)
	{
		startApp(logging, port, netlogging, "/tmp/", "/tmp/", false, false);
	}

	
	public void startApp(boolean logging, int port, boolean netlogging, String audioIpcKey, String videoIpcKey)
	{
		startApp(logging, port, netlogging, "/tmp/", "/tmp/", false, false);
	}

	public void startApp(boolean logging, int port, boolean netlogging, String audioIpcKey, String videoIpcKey, boolean moreipcthreads)
	{
		startApp(logging, port, netlogging, audioIpcKey, videoIpcKey, moreipcthreads, false);
	}
	public void startApp(boolean logging, int port, boolean netlogging, String audioIpcKey, String videoIpcKey, boolean moreipcthreads, boolean disabletls)
	{
		if(isAppRunning())
		{
			return;
		}
		String parameterstring=new String("");
		
		if(port==-1)
		{
			parameterstring+=SKYPEKIT_PARAMETERS_PREFIX_LOCALSOCKET;
		}
		else
		{
			parameterstring+=SKYPEKIT_PARAMETERS_PREFIX_TCPSOCKET+port;
		}
		if(netlogging)
		{
			parameterstring+=SKYPEKIT_PARAMETERS_NETLOGGING_ENABLED;
		}
		else
		{
			parameterstring+=SKYPEKIT_PARAMETERS_NETLOGGING_DISABLED;
		}
		if(disabletls)
		{
			parameterstring+=SKYPEKIT_PARAMETERS_NO_TLS;
		}
		if(moreipcthreads)
		{
			parameterstring+=SKYPEKIT_PARAMETERS_INCREASE_IPC_THREADS;
		}

		parameterstring+=SKYPEKIT_PARAMETERS_AUDIO_IPC_KEY+audioIpcKey;
		parameterstring+=SKYPEKIT_PARAMETERS_VIDEO_IPC_KEY+videoIpcKey;

		if(logging)
		{
			parameterstring+=SKYPEKIT_PARAMETERS_POSTFIX_LOGGING;
		}
		else
		{		
			parameterstring+=SKYPEKIT_PARAMETERS_POSTFIX_NOT_LOGGING;
		}
		startApp(parameterstring);
	}

	/**
	 * Try to start the application. This function will block the caller thread
	 * until the application process is started in a new thread. Use
	 * {@link #isAppRunning()} to check if the application is actually started
	 * and running when this function returns.
	 * 
	 * @param options
	 *            Provide the options needed
	 * @see #isAppRunning()
	 */
	private synchronized void startApp(String options) {
		mSkypeKitOptions = options;
		// Create a new thread to run the application from
		Thread runthread = new Thread(this);
		// We start the thread and wait for it to notify us.
		runthread.start();
		try {
			this.wait();
		} catch (InterruptedException e) {
			// Probably not fully started yet, they will find out later
		}
	}

	/**
	 * Check if the application is still running
	 * 
	 * @return true if process is created successfully and not interrupted,
	 *         false otherwise
	 */
	public static boolean isAppRunningStatic() {
		return mIsAppRunning;
	}
	public boolean isAppRunning() {
		return mIsAppRunning;
	}

	/**
	 * Interrupt the application.
	 */
	public synchronized void stopApp()
	{
		if(!isAppRunning())
		{
			return;
		}
	    // Calling destroy on the Process object to kill skypekit
	    mAppProcess.destroy();
	}

	private String getHex(byte[] ba)
	{
		String s=new String("");
		for(int n=0;n<ba.length;n++)
		{
			s+=Integer.toHexString(ba[n] & 0xff);
		}
		return s;
	}
	
	private boolean chmod(File path, String mode) {
		Process proc;
		try {
			proc = Runtime.getRuntime().exec("chmod " + mode + " " + path.getCanonicalPath());
		} catch (IOException e) {
			return false;
		}
		
		try {
			proc.waitFor();
		} catch (InterruptedException e) {
			return false;
		}
		
		if (proc.exitValue() != 0) {
			return false;
		}
		
		return true;
	}
	
	private void fixPermissions(File filesList[]) {
		if (filesList != null) {
			for (File file : filesList) {
				// Don't change permissions of skypekit binary:
				if (file.getName().equalsIgnoreCase("skypekit")) {
					continue;
				}
				
				if (file.isDirectory()) {
					chmod(file, "700");
					fixPermissions(file.listFiles());
				} else {
					chmod(file, "600");
				}
			}
		}
	}
	
	@Override
	public void run() {

		Log.d(TAG,"SkypeKitRunner thread started");
		try {
			String ls_str;
			Process ls_proc = Runtime.getRuntime().exec("ps | grep skypekit");
			BufferedReader ls_in = new BufferedReader(new InputStreamReader(ls_proc.getInputStream()), 8 * 1024);
			try {
				while ((ls_str = ls_in.readLine()) != null) {
					if(ls_str.indexOf("skypekit") > 0){
						String [] tmp = ls_str.split("\\s+");
						int pid = Integer.parseInt(tmp[1]);
						android.os.Process.killProcess(pid);
					}
				}
			} catch (IOException e) {
			}
		} catch (IOException e1) {
		}

		// First retrieve the filename and path where it will be stored
		String filename = null;
		try {
			// Get the filename
//			filename = mContext.getResources()
//					.getResourceEntryName(mResourceId);
			filename="skypekit";
		} catch (Resources.NotFoundException e) {
			// Notify start failure
			synchronized (this) {
				this.notify();
			}
		}

		Log.d(TAG,"Checkpoint 1, filename='"+filename+"', overwritefile='csf'");
		
		// Get the full expected path of the file
		File file=mContext.getFileStreamPath(filename);
		File csf=mContext.getFileStreamPath("csf");

		// Check if we got to (re)write skypekit executable
		boolean fileExists;
		boolean exewritten=false;
		boolean invalidcsf=false;
		byte[] myversionhash=new byte[16];

		// generate my installation package version hash
		try
		{
			MessageDigest md=MessageDigest.getInstance("MD5");
			md.reset();
			md.update(MAITSEAINE);
			md.update(Package.getPackage(mContext.getPackageName()).getImplementationVersion().getBytes());
			myversionhash=md.digest();
		}
		catch(NoSuchAlgorithmException e)
		{
			Log.e(TAG,"MD5 algorithm not supported by MessageDigest implementation");
			invalidcsf=true;
		}
		if(!invalidcsf)
		{
			if(csf.exists())
			{
				if(file.exists())
				{
					// check if version upgrade has occurred
					try
					{
						InputStream is = new BufferedInputStream(mContext.openFileInput("csf"));
						byte[] csfversionhash=new byte[16];
						is.read(csfversionhash,0,16);
						is.close();
						Log.d(TAG,"csf='"+getHex(csfversionhash)+"', miv='"+getHex(myversionhash)+"' result="+Arrays.equals(csfversionhash,myversionhash));
						if(Arrays.equals(csfversionhash,myversionhash))
						{
							// skypekit does not need to be overwritten
							fileExists=true;
						}
						else
						{
							// Skype has been upgraded or reinstalled
							fileExists=false;
						}
					}
					catch(Exception e)
					{
						Log.e(TAG,"Exception when deciding whether to overwrite executable. Defaulting to overwrite.");
						e.printStackTrace();
						fileExists=false;
					}				
				}
				else
				{
					// skypekit file is missing for some reason
					Log.w(TAG,filename+" file is missing but csf is found.");
					fileExists=false;
				}
			}
			else
			{
				if(file.exists())
				{
					// csf file is missing for some reason
					Log.w(TAG,"csf file is missing but "+filename+" is found.");
					fileExists=false;
				}
				else
				{
					// a fresh installation or files directory wiped
					fileExists=false;
				}
			}
		}
		else
		{
			//csf mechanism cannot be used - just overwrite
			fileExists=false;
		}
		
		// Write executable from resources into file system if needed
		if (!fileExists) {
			
			Log.d(TAG,"Checkpoint 2");

			InputStream is = null;
			OutputStream os = null;
			
			// glue the resources together to build an skypekit executable
			/*
			int[] skypekitTable;
			int numresourcechunks=5;
			skypekitTable=new int[numresourcechunks];
			skypekitTable[0]=R.raw.skypekit_a;
			skypekitTable[1]=R.raw.skypekit_b;
			skypekitTable[2]=R.raw.skypekit_c;
			skypekitTable[3]=R.raw.skypekit_d;
			skypekitTable[4]=R.raw.skypekit_e;
			*/
			
			// load dynamically runtime any number of resources
			// skypekit.exe must be split into max. 1MB resource chunks named "skypekit_*" where *=a..z
			int[] skypekitTable=new int[10]; // Maximum size of skypekit executable is set here to 10MB.

			
			//String resourcenameprefix="com.skype.ipc:res.raw/skypekit_";
			String resourcenameprefix="skypekit_";
			char resourcenameiterator='a';
			int numresourcechunks;
			for(numresourcechunks=0;numresourcechunks<10;numresourcechunks++)
			{
				Log.d(TAG,"Getting resource handle for '"+resourcenameprefix+resourcenameiterator+"' of type 'raw' from package '"+mContext.getPackageName()+"'");
				
				skypekitTable[numresourcechunks]=mContext.getResources().getIdentifier(resourcenameprefix+resourcenameiterator,"raw",mContext.getPackageName());//.raw.skypekit_a;
				if(skypekitTable[numresourcechunks]==0)
				{
					Log.d(TAG,"No handle found.");
					break;
				}
				Log.d(TAG,"Handle="+skypekitTable[numresourcechunks]);
				resourcenameiterator+=1;
			}
						
			try {
				
				// Now open an output stream to a file
				os = new BufferedOutputStream(mContext.openFileOutput(filename,
						Context.MODE_WORLD_READABLE
								| Context.MODE_WORLD_WRITEABLE));

				int n=0;

				for(int i=0;i<numresourcechunks;i++)
				{
					// Get the InputStream of the resource
					is = mContext.getResources().openRawResource(skypekitTable[i]);
					// Now copy the InputStream to the OutputStream
					byte[] b = new byte[1000];
					int read = 0;
					while ((read = is.read(b)) > 0) {
						os.write(b, 0, read);
						n++;
					}
					Log.d(TAG,"skypekit Resource iteration="+i+" totalsize="+(n*1000));
					// Final flush of the file
					os.flush();
				}
				os.close();
				os = null;
				is.close();
				is = null;
				// We have the file now
				exewritten=true;
				fileExists=true;
			} catch (Resources.NotFoundException e) {
				Log.e(TAG,"Executable resources missing or not found");
				// Notify that starting finished, failing
				synchronized (this) {
					this.notify();
				}
			} catch (FileNotFoundException e) {
				Log.e(TAG,"FileNotFoundException when creating executable");
				// Notify that starting finished, failing
				synchronized (this) {
					this.notify();
				}
			} catch (IOException e) {
				Log.e(TAG,"IOException when creating executable");
				// Error copying the file, starting will fail later
			}

			
			
			try {
				if (os != null) {
					os.close();
				}
				if (is != null) {
					is.close();
				}
			} catch (IOException e) {
				// Exception in closing, should be closed
			}
		}

		Log.d(TAG,"Checkpoint 3");

		// Check if csf need to be updated
		if(exewritten && fileExists && (!invalidcsf))
		{
			try
			{
				OutputStream os = new BufferedOutputStream(mContext.openFileOutput("csf",
						Context.MODE_WORLD_READABLE
						| Context.MODE_WORLD_WRITEABLE));
				os.write(myversionhash);
				os.close();
			}
			catch(Exception e)
			{
				Log.w(TAG,"Could not write new csf. Exe will be rewritten at next startup.");
			}
		}
		
		// Skypekit executable should exist by now
		if (fileExists) {
			try {
				// Now we need to change the attributes to executable
				mAppProcess = Runtime.getRuntime().exec(
						"chmod 750 " + file.getCanonicalPath());
				mAppProcess.waitFor();
				if (mAppProcess.exitValue() != 0) {
					Log.d(TAG,"Checkpoint 3.5 - could not chmod for '"+file.getCanonicalPath()+"'");
					throw new IOException(
							"Application attributes could not be changed");
				}
				
				Log.d(TAG,"Checkpoint 4 - Chmod done for '"+file.getCanonicalPath()+"'");
				
				mAppProcess = null;
				// Set the HOME environment variable
				String[] env = new String[2];
				env[0] = new String("HOME="
						+ mContext.getFilesDir().getAbsolutePath());

				String propfileenvprop="";
				for(int n=2*3;n<(26+2)*3;n++)
				{
					propfileenvprop+=(char)(ENVNAMECOMPONENTS[n]^ENVNAMECOMPONENTS[n+1]^ENVNAMECOMPONENTS[n+2]);
					n+=2;
				}
				env[1] = propfileenvprop+"="+System.getenv(propfileenvprop);
//				env[1] = "ANDROID_PROPERTY_WORKSPACE="+System.getenv("ANDROID_PROPERTY_WORKSPACE");
				// And now, we will launch the application
				String skypekitcommand=(file.getCanonicalPath() + mSkypeKitOptions + mContext.getFilesDir().getAbsolutePath());
				Log.d(TAG,"Checkpoint 4.5 - about to launch '"+skypekitcommand+"' with env0='"+env[0]+"', env1='"+env[1]+"'");
				
				File files[] = new File[1];
				files[0] = mContext.getFilesDir(); // include the root data folder
				fixPermissions(files);
				mAppProcess = Runtime.getRuntime().exec(skypekitcommand, env, mContext.getFilesDir());
				mIsAppRunning = true;
				synchronized (this) {
					this.notify();
				}

				Log.d(TAG,"Checkpoint 5 - skypekit launched, mAppProcess="+mAppProcess);

				InputStreamReader isr = new InputStreamReader(mAppProcess.getInputStream());
				BufferedReader br = new BufferedReader(isr, 8 * 1024);
				String line = null;
				Log.d(TAG,"skypekit output:");
				while ( (line = br.readLine()) != null) {
					Log.d(TAG, line);
				}
				// This can lead to an interrupted
				int retcode=mAppProcess.waitFor();
				Log.d(TAG,"skypekit has exited with exit code "+retcode);

				// TODO: How do we handle skypekit being killed or crashing?
				
				appStopped();
				mAppProcess = null;
			} catch (InterruptedException e) {

				Log.d(TAG,"Checkpoint 6.5 - mAppProcess.waitFor threw with mIsAppRunning==false");

				// Caused by process.waitFor()
				if (!mIsAppRunning) {
					synchronized (this) {
						this.notify();
					}
				} else {
					// We were running, so notify the interrupt

					Log.d(TAG,"Checkpoint 7 - mAppProcess.waitFor threw with mIsAppRunning==true");
					
					appStopped();
				}
			} catch (Exception e) {
				Log.d(TAG,"Checkpoint 7.5 - exception"+e);
				if (!mIsAppRunning) {
					Log.d(TAG,"Checkpoint 7.6");
					synchronized (this) {
						this.notify();
					}
				}
			}

			Log.d(TAG,"Checkpoint 7.7");

			if (mAppProcess != null) {
				Log.d(TAG,"Checkpoint 7.8");
				mAppProcess = null;
			}
		} else {
			Log.d(TAG,"Checkpoint 8 - file does not exist!!");
			// Notify start failure
			synchronized (this) {
				this.notify();
			}
		}
	}

	private synchronized void appStopped() {
		Log.d(TAG,"Checkpoint 567 - appStopped called");
		mIsAppRunning = false;
		if (mStopNotify) {
			this.notify();
		}
		if(mListener!=null)
		{
			mListener.skypekitStopped();
		}
	}
}
