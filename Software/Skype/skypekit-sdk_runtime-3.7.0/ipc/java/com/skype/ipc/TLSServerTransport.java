/**
 * Copyright (C) 2010, Skype Limited
 *
 * All intellectual property rights, including but not limited to copyrights,
 * trademarks and patents, as well as know how and trade secrets contained in,
 * relating to, or arising from the internet telephony software of
 * Skype Limited (including its affiliates, "Skype"), including without
 * limitation this source code, Skype API and related material of such
 * software proprietary to Skype and/or its licensors ("IP Rights") are and
 * shall remain the exclusive property of Skype and/or its licensors.
 * The recipient hereby acknowledges and agrees that any unauthorized use of
 * the IP Rights is a violation of intellectual property laws.
 *
 * Skype reserves all rights and may take legal action against infringers of
 * IP Rights.
 *
 * The recipient agrees not to remove, obscure, make illegible or alter any
 * notices or indications of the IP Rights and/or Skype's rights and
 * ownership thereof.
 */

package com.skype.ipc;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.LinkedList;
import java.lang.reflect.Method;

import javax.net.ssl.KeyManager;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLEngineResult.HandshakeStatus;
import javax.net.ssl.SSLEngineResult.Status;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509ExtendedKeyManager;
import javax.net.ssl.X509TrustManager;
import java.util.Arrays;
import com.skype.util.Log;

/**
 * @author kcjones
 *
 */
public class TLSServerTransport implements Transport
{
	private static final String TAG = "TLSServerTransport";
	private static int MAXBUF;
	
	private boolean connected = false;
	private Transport transport = null;
	private SSLEngine engine = null;
	private SSLContext context = null;
    private FileOutputStream logFileOut = null;
    private FileOutputStream logFileIn = null;
    private boolean isLogging = false;

	private X509ExtendedKeyManager keyManager = null;
	private TrustManager trustManager = null;

	private LinkedList<byte[]> decrypted_chunks = new LinkedList<byte[]>();
	private ByteArrayInputStream decryptedStream = new ByteArrayInputStream(new byte[0]);
    private ByteBuffer raw_source = null;

    public TLSServerTransport(Transport t, X509Certificate cert, PrivateKey privKey)
    {
        transport = t;

        trustManager = new dummyTrustManager();
        keyManager = new dummyKeyManager(cert,privKey);
        decrypted_chunks.clear();
    }
	
	protected void finalize() throws Throwable
	{
	    super.finalize();
	    if (isLogging) {
	        logFileOut.flush();
	        logFileOut.close();
	        logFileIn.flush();
	        logFileIn.close();
	    }
	}

	@Override
	public void startLogging(String logFileName)
	{
	    assert(!isLogging);
	    
        if (logFileName != null && ! logFileName.isEmpty()) {
            try {
                logFileOut = new FileOutputStream(new File(logFileName + ".out.bin"), false);
                logFileIn  = new FileOutputStream(new File(logFileName + ".in.bin"), false);
                isLogging = true;
                Log.d(TAG, "Transport logging started");
            }
            catch (FileNotFoundException e) {
                Log.e(TAG, "Unable to open transport log files using:" + logFileName);
            }
        }
	}
	
	void do_handshake() throws SSLException, IOException 
	{
		byte leftover_bytes[] = new byte[]{};

		Log.d(TAG, "do_handshake()");
		SSLEngineResult engineResult = null;
		HandshakeStatus result =  HandshakeStatus.NEED_UNWRAP;
		while(true) {
			switch(result) {
			case FINISHED:
				Log.d(TAG, result.toString());
				return;
			case NEED_TASK:
				Log.d(TAG, result.toString());
				Runnable task;
				while((task=engine.getDelegatedTask()) != null) {
					task.run();
				}
				break;
			case NEED_UNWRAP: {

				byte [] msg = new byte [16384];
				int idx = 0;
				Log.d(TAG, result.toString());

				if (leftover_bytes.length == 0) {
					try {
						transport.peek();
						while(transport.hasMore() ) {
							msg[idx++] = (byte) transport.read();
						}
					}
					catch (IOException e) {
						Log.e(TAG, "Read exception:" + e.getMessage() + ":" + e.getCause());
						throw e;
					}
				}
				else {
					idx = leftover_bytes.length;
					System.arraycopy(leftover_bytes, 0, msg, 0, idx);
					leftover_bytes = new byte[]{};
				}

				ByteBuffer src0 = ByteBuffer.wrap(msg);
				ByteBuffer dst0 = ByteBuffer.allocate(16384);
				engineResult = engine.unwrap(src0, dst0);
				result = engineResult.getHandshakeStatus();
				int bytesConsumed = engineResult.bytesConsumed();

				int sum = 0; //check if we had trailing zeroes
				while(bytesConsumed < idx)
					sum |= msg[bytesConsumed++];

				int bytesLeftOver = idx - engineResult.bytesConsumed();
				if (sum != 0 && bytesLeftOver > 0 ) { //more than one message, keep a copy
					leftover_bytes = new byte[bytesLeftOver];
					System.arraycopy(msg, engineResult.bytesConsumed(), 
							leftover_bytes, 0, bytesLeftOver);
				}
				break;
			}
			case NEED_WRAP: {
				Log.d(TAG, result.toString());
				ByteBuffer EMPTY = ByteBuffer.allocate(0);
				ByteBuffer dst1 = ByteBuffer.allocate(65536);
				engineResult = engine.wrap(EMPTY, dst1);
				byte [] bytes2send = new byte[engineResult.bytesProduced()];
				dst1.rewind();
				dst1.get(bytes2send);
				transport.write(bytes2send.length , bytes2send);
				break;
			}
			case NOT_HANDSHAKING:
				Log.d(TAG, "discarding " + leftover_bytes.length + " bytes");
				if (leftover_bytes.length > 0) {
					ByteBuffer s = ByteBuffer.wrap(leftover_bytes);
					Log.hexdump(s.array());
					leftover_bytes = new byte[] {};
				}
				Log.d(TAG, result.toString());
				return;
			}
			result = engine.getHandshakeStatus();

		}
	}

	void checkConnected() throws IOException
	{
		if (!connected) 
			throw new IOException("TLSServerTransport not connected!");
	}

	@Override
	public boolean connect() throws IOException
	{
		Log.d(TAG, "connect()");

		if (!transport.connect()) 
			return false;

		try {
			context = SSLContext.getInstance("TLS");
		} catch (NoSuchAlgorithmException e) {
			throw new IOException("TLSServerTransport:IOException:" + e.getMessage() );
		}
		KeyManager [] km = { keyManager };
		TrustManager [] tm = { trustManager };
		try {
			context.init(km, tm, null);
		} catch (KeyManagementException e) {
			throw new IOException("TLSServerTransport:KeyManagementException:" + e.getMessage() );
		}
		engine = context.createSSLEngine();
		engine.setUseClientMode(false);
		engine.setNeedClientAuth(false);
		engine.setWantClientAuth(false);

		try {
			@SuppressWarnings("rawtypes")
            Class c = Class.forName("javax.net.ssl.SSLEngine");
			for (Method m : c.getDeclaredMethods() ) {
				if (m.getName() == "getSSLParameters") { //this is not supported on Android < 2.3
					SSLParameters params = engine.getSSLParameters();
					params.setCipherSuites(new String [] { 
						"TLS_RSA_WITH_AES_128_CBC_SHA"
					});
					engine.setSSLParameters(params);
					}
				}
			}
		catch (ClassNotFoundException e) { //shouldnt ever happen
		}

		try {
			do_handshake();
		} 
		catch (SSLException e) {
		    throw new IOException("TLSServerTransport:handshake_failed:" + e.getMessage(), e);
		}
		catch (IOException e) {
		    throw new IOException("TLSServerTransport:handshake_failed:" + e.getMessage(), e);
		}
		connected = true;

		X509Certificate cert = keyManager.getCertificateChain("dummyServer")[0];
		byte[] certBytes = null;
		try {
			certBytes = cert.getEncoded();
		} catch (CertificateEncodingException e) {
			e.printStackTrace();
		}
		String lenStr = String.format("%08X", certBytes.length);
		byte [] lenBytes = lenStr.getBytes();
		write(lenBytes.length,lenBytes);
		write(certBytes.length,certBytes);

		return true;
	}

	@Override
	public void disconnect() throws IOException
	{
		checkConnected();
		
		transport.disconnect();
	}

	@Override
	public boolean hasMore() throws IOException 
	{
		// never used, according to KCJ
		assert(false);
		
		return false;
	}

	@Override
	public boolean isConnected() throws IOException
	{
		return transport.isConnected();
	}

	@Override
	public int peek() throws IOException
	{
		if (decryptedStream.available() == 0) {
			// this will block until bytes arrive, but we return a decrypted byte after this returns
			transport.peek();			
			readMore();
		}
		
		decryptedStream.mark(1);
		int b = decryptedStream.read();
		decryptedStream.reset();
		return b;
	}

	@Override
	public int read() throws IOException
	{
		if (decryptedStream.available() > 0)
			return decryptedStream.read();
		
		byte b[] = new byte[]{'0'};
		read(1,b);

		return b[0];
	}

	@Override
	public synchronized int read(int numBytes, byte[] bytes) throws IOException
	{
		checkConnected();

		int len, offset = 0, remaining = numBytes;
		while ((len = decryptedStream.available()) < remaining) {
			if (len > 0) {
				decryptedStream.read(bytes, offset, len);
				offset += len;
				remaining -= len;
			}

			readMore();
		}

		decryptedStream.read(bytes, offset, remaining);
		return numBytes;
	}
	
	@Override
	public int read(int numBytes, byte[] bytes, boolean needNumBytes) throws IOException
	{
		int bytesRead = read(numBytes, bytes);
		return bytesRead;
	}

	/**
	 * drain all input from transport stream and decrypt using engine.
	 * 
	 * @param raw_bytes - buffer to accept unwrapped bytes read from socket
	 * @throws IOException - when read buffer is too small, or other socket read exceptions thrown
	 */
	protected void readMore() throws IOException
	{
		assert(decryptedStream.available() == 0);
		if (decrypted_chunks.isEmpty()) {
			readChunks();
		}
		// either we find soemthing to read, or throw an exception
		assert( ! decrypted_chunks.isEmpty());
		byte [] chunk = decrypted_chunks.removeFirst();
		decryptedStream = new ByteArrayInputStream(chunk);
	}
	
	protected void readChunks() throws IOException
	{
		// allocate byte buffers to match session parameters exactly
		if (raw_source == null) {
			SSLSession s = engine.getSession();
			MAXBUF = s.getPacketBufferSize();
			if (s.getApplicationBufferSize() > MAXBUF) {
				MAXBUF = s.getApplicationBufferSize();
			}
			Log.d(TAG, "SSLSession packet size:" + MAXBUF);
			raw_source = ByteBuffer.allocate(MAXBUF);

		}

		int pos = raw_source.position();
//			System.err.println("reading "+pos);
		do {
			raw_source.put((byte)transport.read());
		} while( transport.hasMore() &&	raw_source.position() < MAXBUF );

		if (pos == raw_source.position()) {
//			System.err.println("nothing read");
			Log.d(TAG, "Nothing read.");
			return;
		}
//		System.err.println("read "+raw_source.position());

		ByteBuffer dst = ByteBuffer.allocate(MAXBUF); 
		boolean unwrap_ok = false;
		int loop = 0;
		do {
			SSLEngineResult engineResult;
			try {
	 			raw_source.flip();
//				System.err.println("unwrapping "+raw_source.remaining());
				engineResult = engine.unwrap(raw_source, dst);
				raw_source.compact();
//				System.err.println("unwrapped "+raw_source.position()+" "+raw_source.limit());
			} catch (SSLException e) {
				String msg = "unwrap failed at bytes "+engine.getSession().getCipherSuite();
				System.err.println(msg);
				Log.d(TAG, msg);
				throw e;
			}

			SSLEngineResult.Status unwrap_status = engineResult.getStatus();
			//Log.d(TAG, "unwrap status:" + unwrap_status);
			unwrap_ok = unwrap_status == SSLEngineResult.Status.OK; 
			if (unwrap_ok || unwrap_status == SSLEngineResult.Status.BUFFER_UNDERFLOW)
			{
				int l = engineResult.bytesProduced();
				//Log.d(TAG, "decrypted length:" + l);
				if (l > 0 || loop == 0) {
					loop++;
					byte [] chunk = new byte[l];
					dst.rewind();
					dst.get(chunk, 0, l);
					dst.clear();
					if (isLogging)
						logFileIn.write(chunk);

					decrypted_chunks.addLast(chunk);
				}
//					if (!unwrap_ok) 
//						System.err.println("underflow, adding chunk with "+l+" bytes, remains "+raw_source.position());
//					else
//						System.err.println("ok, adding chunk with "+l+" bytes, remains "+raw_source.position());
			}
			else {
				throw new IOException("Unrecoverable TLS error: " + unwrap_status);
			}
		} while (unwrap_ok && raw_source.position() > 0);
//		System.err.println("end reading");
	}
	
	private void dumpSourceBuffer(String tag)
	{
	    int pos = raw_source.position();
	    int lim =raw_source.limit();
        Log.e(TAG, "---" + tag + " position:" + pos + " limit:" +  lim);
        
        if (raw_source.hasArray() && pos < lim) {
            byte [] src = raw_source.array();
            byte [] section = new byte[lim - pos];
            System.arraycopy(src, pos, section, 0, lim - pos);
            Log.hexdump(section);
        }
	}

	@Override
	public boolean write(byte b) throws IOException
	{
		Log.e(TAG, "FAIL! write(" + b + ")");
		throw new IOException("Invalid use of TLS transport");
	}

	@Override
	public boolean write(int numBytes, byte[] bytes)
	throws IOException
	{
		checkConnected();

		if (isLogging) {
			logFileOut.write(bytes, 0, numBytes);
		}

		SSLSession s            = engine.getSession();
		int begin = 0;
		int packetBufferSize        = s.getPacketBufferSize();
        	ByteBuffer dst = ByteBuffer.allocate(packetBufferSize);
		ByteBuffer src = ByteBuffer.wrap(bytes);
		while (numBytes > 0) {
		        SSLEngineResult engineResult = engine.wrap(src, dst);
			if (engineResult.getStatus() != SSLEngineResult.Status.OK)  {
				throw new IOException("error when wrapping");
			}
			numBytes -= engineResult.bytesConsumed();
//				System.err.println("write, remains "+numBytes);
		        transport.write(dst.position(),  dst.array());
			dst.clear();
		}

		return false;
	}

	public class dummyKeyManager extends X509ExtendedKeyManager {
		X509Certificate cert;
		PrivateKey privKey;

		public dummyKeyManager(X509Certificate _cert,PrivateKey _privKey) {
			privKey = _privKey;
			cert = _cert;
		}

		@Override
		public String chooseClientAlias(String[] arg0, Principal[] arg1, Socket arg2) {
			Log.d(TAG, "chooseClientAlias");
			return null;
		}

		public String chooseEngineServerAlias(String keyType, Principal[] issuers, SSLEngine engine) {
			Log.d(TAG, "chooseEngineServerAlias " + keyType);
			if (keyType == "RSA") {
				return "dummyServer";
			}
			return null;
		}

		@Override
		public String chooseServerAlias(String keyType, Principal[] issuers, Socket arg2) {
			Log.d(TAG, "chooseServerAlias");
			return null;
		}

		@Override
		public X509Certificate[] getCertificateChain(String arg0) {
			Log.d(TAG, "getCertificateChain");
			return new X509Certificate[] { cert };
		}

		@Override
		public String[] getClientAliases(String arg0, Principal[] arg1) {
			Log.d(TAG, "getClientAliases");
			return null;
		}

		@Override
		public PrivateKey getPrivateKey(String arg0) {
			Log.d(TAG, "getPrivateKey");
			return privKey;
		}

		@Override
		public String[] getServerAliases(String arg0, Principal[] arg1) {
			Log.d(TAG, "getServerAliases");
			return null;
		}
	}

	/* 
	 * This class should never be called
	 * */
	public class dummyTrustManager implements X509TrustManager {
		@Override
		public void checkClientTrusted(X509Certificate[] arg0, String arg1)
		throws CertificateException {
			throw new CertificateException("dummyTrustManager:checkClientTrusted called");
		}

		@Override
		public void checkServerTrusted(X509Certificate[] arg0, String arg1)
		throws CertificateException {
			throw new CertificateException("dummyTrustManagercheckServerTrusted called");
		}

		@Override
		public X509Certificate[] getAcceptedIssuers() {
			Log.d(TAG, "dummyTrustManager:getAcceptedIssuers");
			return null;
		}
	}
}
