
#include "videowidget.h"
#include "QSKClasses.h"

#include <QPainter>

//#define PROCESS_COMMANDS_IN_OTHER_THREAD


VideoWidget::VideoWidget( QWidget *parent )
        : QWidget( parent )
{
    // Here we will inform the runtime that we are capable of drawing
    // RGB32 and RGB24 bitmaps. The runtime will pick the most suitable
    // of those. Format of the frames we receive back will be included in the
    // bufferstruct's colorspace and bitcount fields
/*
    unsigned long list[2];
    list[0] = SID_MAKEFOURCC('B','I','3','2');
    list[1] = SID_MAKEFOURCC('B','I','2','4');
    SetPreferences( list, 2 );
    currentwidth = 0;
*/
}

// Starts polling the transport mechanism for new frames.
void VideoWidget::renderStart()
{
/*
    dispatcher->log("Starting videorenderer");
    timerId = startTimer(10);
*/
}

// Stops the timer.
void VideoWidget::renderStop()
{
/*
    dispatcher->log("Stopping videorenderer");
    killTimer(timerId);
*/
}

// Handling widget close event
void VideoWidget::closeEvent ( QCloseEvent * e )
{
/*
    renderStop();
*/
};

// paintEvent will be called from the Qt main thread.
void VideoWidget::paintEvent( QPaintEvent *event )
{
    // Retrieving current state of the frame buffer and locking it.
/*
    bufferstruct *b = LatestBuffer();
    if ( b )
    {
        // Now we need to check the actual bitmap format of the frame
        QImage::Format f;
        // First, lets see if the format is given explicitly in buffer's colorspace
        if (        b->colorspace == SID_MAKEFOURCC('B','I','3','2') ) f = QImage::Format_RGB32;
        else if (   b->colorspace == SID_MAKEFOURCC('B','I','2','4') ) f = QImage::Format_RGB888;
        else if ( b->colorspace == 0  )
        {
            // FOURCC == 0 is also a valid value, in which case the actual format can be
            // either RGB32, RGB24 or RGB 16. Between those we can choose based on buffer's bitcount

            if ( b->bitcount == 32 ) f = QImage::Format_RGB32;
            else if ( b->bitcount == 24 )
                        f = QImage::Format_RGB888;
                else if ( b->bitcount == 16 )
                        f = QImage::Format_RGB16;
        }


        // Creating image and drawing it..
        QImage img( (const uchar *)DataForBuffer(b), b->width, b->height, f );
        QPainter painter( this );
        painter.drawImage( rect(), img );

        // ..and releasing buffer.
        AddFreeBuffer( b );
    }
*/
};


// This will be called from timer event. As we cannot draw frames here directly,
// we will instead call update() that queues paintEvent to be fired when appropriate.

bool VideoWidget::Present( void *, bufferstruct *b, long long )
{
/*
    if ( currentwidth != b->width ) {
        resize( b->width, b->height );
        currentwidth = b->width;
    }
    update();
    return true;
*/
};

void VideoWidget::timerEvent( QTimerEvent * )
{
/*
    ReceiveCommand( true );
*/
};


